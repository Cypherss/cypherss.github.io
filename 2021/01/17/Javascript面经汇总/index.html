<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="事件代理 事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能 具体原因看Q21事件冒泡机制  请解释Javascript中的this是如何工作的（如何正确判断） this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。 在call和apply中this">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript面经汇总">
<meta property="og:url" content="http://example.com/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Cypherss&#39;s Blog">
<meta property="og:description" content="事件代理 事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能 具体原因看Q21事件冒泡机制  请解释Javascript中的this是如何工作的（如何正确判断） this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。 在call和apply中this">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/prototype5.png">
<meta property="og:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/v2-320935b9afabe806ff20993ead6c1048_1440w.png">
<meta property="og:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/3259161542-575018ce29d44_articlex.png">
<meta property="og:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126200149.png">
<meta property="og:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126202303.png">
<meta property="article:published_time" content="2021-01-17T06:52:11.000Z">
<meta property="article:modified_time" content="2021-01-26T12:51:40.363Z">
<meta property="article:author" content="Chen Zhengyu">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="Javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/prototype5.png">

<link rel="canonical" href="http://example.com/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Javascript面经汇总 | Cypherss's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cypherss's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人都有各自的月亮</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Chen Zhengyu">
      <meta itemprop="description" content="Have a nice day!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cypherss's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Javascript面经汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-17 14:52:11" itemprop="dateCreated datePublished" datetime="2021-01-17T14:52:11+08:00">2021-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-26 20:51:40" itemprop="dateModified" datetime="2021-01-26T20:51:40+08:00">2021-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/17/Javascript面经汇总/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ol>
<li><p>事件代理</p>
<p>事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能</p>
<p>具体原因看Q21事件冒泡机制</p>
</li>
<li><p>请解释Javascript中的this是如何工作的（如何正确判断）</p>
<p>this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。</p>
<p>在call和apply中this指向指定的对象，如果指定的参数是null或undefined，则指向window。</p>
<p>在箭头函数中，箭头函数是没有this的，因此this指向外层代码的对象。</p>
<a id="more"></a>
</li>
<li><p>原始值和引用值类型以及区别</p>
<p>JS的原始数据类型有boolean，null，undefined，bigint，number，string，symbol</p>
<p>引用数据类型：对象Object（普通，数组，正则，日期，数学，函数）</p>
<p>区别：</p>
<p>（1）值类型：</p>
<p>​            1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）</p>
<p>​            2、保存与复制的是值本身</p>
<p>​            3、使用typeof检测数据的类型</p>
<p>​            4、基本类型数据是值类型</p>
<p>（2）引用类型：</p>
<p>​            1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</p>
<p>​            2、保存与复制的是指向对象的一个指针</p>
<p>​            3、使用instanceof检测数据类型</p>
<p>​            4、使用new()方法构造出的对象是引用型</p>
</li>
<li><p>闭包与作用域</p>
<p>闭包是指那些能够访问自由变量的函数。（闭包 = 函数 + 函数能够访问的自由变量）/闭包是指有权访问另外一个函数作用域中的变量的函数</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li><p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>
</li>
<li><p>在代码中引用了自由变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();<span class="comment">//0</span></span><br><span class="line">data[<span class="number">1</span>]();<span class="comment">//1</span></span><br><span class="line">data[<span class="number">2</span>]();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>作用域：JS使用词法（静态）作用域，即函数的作用域在函数定义的时候就被确定了</p>
</li>
</ol>
<p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
</li>
<li><p>js继承</p>
<p>js中的继承需要靠原型来实现。</p>
<p>但是继承有一个问题是父类的所有属性，子类都会继承，因此使用组合代替继承是非常必要的。</p>
<p>五种方式实现继承：</p>
<p>​    call（子类中调用parent.call(this)，只能继承属性，但是不能继承方法）</p>
<p>​    借助原型链（child.prototype = new parent()，能继承方法，但是多个子类继承自同一个原型对象，属性值同时改变)</p>
<p>​    前两种组合，但是会导致父类构造函数执行多次</p>
<p>​    将父类原型给到子类的原型（但是子类的构造函数变成了父类）</p>
<p>​    寄生组合继承（最优）</p>
<p>​    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;parent5&#x27;</span>;</span><br><span class="line">   <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent5.call(<span class="built_in">this</span>);</span><br><span class="line">   <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line"> Child5.prototype.constructor = Child5;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>js模块化</p>
<p>AMD,CMD,ES6</p>
<p>AMD和CMD都是通过define()定义模块，AMD需要把依赖的模块先写出来，可以通过return暴露接口，CMD在定义模块需要传入require，exports和module这几个参数，要加载某个模块时，使用require进行加载，要暴露接口时，可以通过exports，module.exports和return。</p>
<p>而es6使用静态化加载而不是运行时加载，通过export和import按需加载（编译时加载）</p>
</li>
<li><p>new的原理</p>
<p>通过new创建对象经历五个步骤：创建一个新对象；设置这个空对象的实例原型；将构造函数的作用域赋给新对象；执行构造函数（赋属性）；返回新对象。</p>
</li>
<li><p>null undefined 区别</p>
<p>null表示”没有对象”，即该处不应该有值。</p>
<p>​    （1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>​    （2） 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>​    （1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>​    （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
</li>
<li><p>IIFE立即执行函数</p>
<p>立即执行函数即立即执行声明的函数（可以是匿名函数），有两种写法</p>
<p>列表1:IIFE写法一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>列表2:IIFE写法二</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<ul>
<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。</li>
<li>IIFE中定义的任何变量和函数，都会在执行结束时被销毁，这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</li>
</ul>
</li>
<li><p>原型和原型链</p>
<p>所谓的原型就是在用构造函数创建对象时就会关联另一个对象A.prototype，并且对象会从这里继承属性。（更多像一种委托，建立关联调用）</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/prototype5.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>简而言之构造函数和实例原型之间是原型和构造的关系，对象之间通过__proto__向上调用.</p>
</li>
<li><p>深拷贝与浅拷贝</p>
<p>浅拷贝只拷贝一层对象，但是深拷贝可以通过递归解决对象嵌套的问题</p>
<p>浅拷贝实现方式：</p>
<ol>
<li>手动实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Object.assign</li>
</ol>
<p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;sy&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">&#x27;sss&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>concat浅拷贝数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>slice浅拷贝</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>…展开运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>深拷贝实现方式

简易版本的是JSON.parse(JSON.stringify())，但是这个方法无法解决循环引用，无法拷贝一些set，map之类的特殊对象，无法拷贝函数。

因此手动实现一个深拷贝(如果属性是对象，则递归;有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。)

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.get(target))&#123;<span class="keyword">return</span> hash.get(target);&#125;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        hash.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = <span class="keyword">typeof</span> target[prop] === <span class="string">&#x27;object&#x27;</span> ? deepClone(target[prop]) : target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还有jquery有一个提供$.extend 可以使用Deep Copy；函数库lodash的_.cloneDeep方法。</code></pre>
<ol start="12">
<li><p>匿名函数</p>
<p>匿名函数可以赋值或者自执行（IIFE），使用匿名函数赋值的时候，要先声明再使用。IIFE除了上面的方法，还可以通过{[], +, -, !, ~, void}调用</p>
</li>
<li><p>判断数据类型的方式</p>
<ol>
<li>typeof返回基本数据类型（除了null），引用类型中除了function返回function，其余返回object；</li>
<li>toString（）是 Object 的原型方法返回class属性，表示为[Object, Xxx]，除了object其他通过call/apply调用。（window-&gt;global, document-&gt;HTMLDocument）</li>
<li>constructor指向构造函数引用</li>
<li>instanceof通过原型链来判断A是否为B的实例（instance of null报错：右边不是一个对象）</li>
</ol>
</li>
<li><p>宿主对象和原生对象</p>
<p>ECMA-262 把原生对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）</p>
<p>由此可以看出，简单来说，原生对象就是 ECMA-262 定义的类（引用类型）。其中有一个子集叫做内置对象Global和Math（所有函数都必须是某个对象的方法）</p>
<p>所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的 BOM 和 DOM 对象都是宿主对象。document，window， navigator等</p>
</li>
<li><p>请指出以下代码的区别：<code>function Person()&#123;&#125;</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>？</p>
<p>第一个是声明一个函数Person；第二个是把函数的返回值赋给person，如果没有返回值就是undefined；第三个是new一个Person的实例对象。</p>
</li>
<li><p>防抖和节流</p>
<p>简而言之：防抖（debounce）让短时间内的连续触发的事件，在一定的时间间隔中，事件处理函数只执行一次；</p>
<p>而节流（throttle）就是让函数执行一次之后，在一段时间内失效，然后再生效（可以执行）。</p>
</li>
<li><p><code>document.write()</code></p>
<p>用于向HTML输出流中添加传入的内容，浏览器会顺着html元素顺序依次解析他们，并且显示出来，但是如果在页面渲染完成之后调用（onload），会重写整个document，导致之前所有的内容被覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(exp1,exp2,exp3,....);</span><br></pre></td></tr></table></figure></li>
<li><p>Ajax工作原理</p>
<p>Ajax(Asynchronous Java and XML的缩写)是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/v2-320935b9afabe806ff20993ead6c1048_1440w.png"></p>
</li>
<li><p>跨域、同源策略及跨域实现方式和原理</p>
<ol>
<li><p>同源策略是一种规定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求不能发送</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>
<p>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p>
<p>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</p>
<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
</li>
<li><p>跨域的九种解决方案</p>
<ol>
<li>JSONP</li>
<li>CORS(CORS 需要浏览器和后端同时支持。)</li>
<li>postMessage(postMessage是HTML5 XMLHttpRequest Level 2中的API;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。)</li>
<li>websocket</li>
<li>Node中间代理(实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。)</li>
<li>nginx反向代理</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>document.domain + iframe(该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。)</li>
</ol>
</li>
<li><p>总结</p>
<ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>
</li>
</ol>
</li>
<li><p>js中的垃圾回收机制</p>
<p>js中的垃圾回收是自动进行的，是不可见的。js中的内存管理主要的概念是可达性，根访问不到的都是垃圾。垃圾回收器会监视左右的对象并且删除不可访问的对象。基本的垃圾回收算法为标记-清除，垃圾回收器获取根，标记它，然后逐层访问并且标记引用的对象，最后除了标记过的，其余的都删除。（可以是删除没有标记的，又有一种是删除有标记的）（以前还有一种引用计数，但是引用计数会有循环引用的问题）</p>
<p>一些优化:</p>
<ul>
<li><strong>分代回收</strong>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li>
<li><strong>增量回收</strong>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li>
<li><strong>空闲时间收集</strong>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li>
</ul>
</li>
<li><p>冒泡机制</p>
<p>冒泡机制是指事件从DOM树的底层一层层向上传递，如果要终止传递可以通过对每一个元素进行event.stopPropagation()，或者通过在父元素中去判断targetid，分别作出相应的处理。</p>
</li>
<li><p>变量声明提升</p>
<p>变量声明会从他们在代码中出现的位置被移动到当前作用域的最上方进行执行，这个过程叫做提升。</p>
<p>函数也存在提升。但是在函数表达式中，由于是赋值，所以不可以提升。</p>
<p>在提升中有函数优先原则，函数反复声明会覆盖。</p>
<p>当然在实际编程中，要尽量避免提升问题。</p>
</li>
<li><p>document load 和 document DOMContentLoaded</p>
<p>当浏览器解析完文档就会触发DOMContentLoaded事件，脚本，css都会阻塞解析。</p>
<p>而当所有资源全部加载完毕之后，才会触发load事件（在DOMContentLoaded事件之后）。</p>
<p>P.S.为什么要js脚本放在最后（<code>&lt;/body&gt;</code>之前)？</p>
<p>​    其实现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p>
</li>
<li><p>== 和 ===有什么不同</p>
<p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p>
<p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p>
<p>操作数1 == 操作数2， 操作数1 === 操作数2</p>
<p>比较过程：</p>
<p>　　双等号==： </p>
<p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p>
<p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p>
<p>　　　　1）如果一个是null，一个是undefined，那么相等</p>
<p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较(或者是boolean)</p>
<p>　　</p>
<p>　　三等号===:</p>
<p>　　（1）如果类型不同，就一定不相等</p>
<p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值                是否是NaN，只能使用isNaN( ) 来判断）</p>
<p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p>
<p>　　（4）如果两个值都是true，或是false，那么相等</p>
<p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p>
<p>　　（6）如果两个值都是null，或是undefined，那么相等</p>
</li>
<li><p>js中的arguments</p>
<p>也是一个对象，是一个特殊的对象，属性的名是根据传入参数的序列来的，又叫做类数组对象。（proto属性指向Object.prototype）</p>
<p>可以通过length判断传入长度，可以索引取值使用参数，可以通过callee属性获取方法完整代码（匿名函数递归）（es4开始禁止？）</p>
</li>
<li><p>请解释什么是单页应用 (<code>single page app</code>), 以及如何使其对搜索引擎友好 (<code>SEO-friendly</code>)</p>
<p>只有一个页面的web应用程序就是单页应用。</p>
<p>单页应用对SEO不太友好，但是可以通过Prerender预渲染优化技术解决一部分问题。</p>
</li>
<li><p>Promise</p>
<p>Promise的出现解决了回调地狱</p>
<p>什么是回调地狱？</p>
<ol>
<li>多层嵌套的问题。</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<p>Promise 利用了三大技术手段来解决<code>回调地狱</code>:</p>
<ul>
<li><strong>回调函数延迟绑定</strong>。</li>
<li><strong>返回值穿透</strong>。</li>
<li><strong>错误冒泡</strong>。</li>
</ul>
<p>本质上 Promise 是一个函数返回的对象，它代表了一个异步操作的最终完成或者失败。我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<p>Promise由于catch，then，finally返回的是一个新的Promise对象，因此实现了链式调用。</p>
<ul>
<li><p>Promise 中有三个状态 Pending（进行中）、Fulfilled（已成功）、Rejected（已失败）。外界无法改变这个三个状态，而且一旦状态改变就不会再变。</p>
</li>
<li><p>实例化一个 Promise 需要传入一个 <code>executor</code> 函数 ，业务代码在 <code>executor</code> 函数中执行，另外 <code>executor</code> 函数接收两个参数 <code>resolve</code> 和 <code>reject</code>。<code>resolve</code> 和 <code>reject</code> 是 Promise 构造函数的内置函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;... 业务代码</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>executor</code> 函数中业务代码执行成功了，调用 <code>resolve</code> 函数，把 Promise 的状态变为已成功，另外通过参数把业务代码的执行成功的结果传递到 Promise 中。</p>
</li>
<li><p>在 <code>executor</code> 函数中业务代码执行失败了，调用 <code>reject</code> 函数，把 Promise 的状态变为已失败，另外通过参数把业务代码的执行失败的原因传递到 Promise 中。</p>
</li>
<li><p>实例方法 <code>then</code> 的第一个参数是业务代码执行成功的回调函数，第二个参数是业务代码执行失败的回调函数，当业务代码执行完毕后，会根据执行结果调用对应的回调函数，且这些回调函数接收业务代码的执行结果作为参数。</p>
</li>
<li><p>通过实例方法 <code>catch</code> 来添加业务代码执行失败的回调函数。</p>
</li>
</ul>
</li>
<li><p>图片懒加载</p>
<p>图片懒加载实际上就是当页面滚动到当前图片的时候，就进行加载</p>
<p>首先有几个API：</p>
<pre><code>                    1. document.documentElement.clientHeight
                       2. element.offsetTop
                       3. document.documentElement.scrollTop</code></pre>
<p>而懒加载的加载条件就是offsetTop - scrollTop &lt; clientHeight</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        img &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">            margin-bottom: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/7.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/8.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/9.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/10.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//offsetTop是元素与offsetParent的距离，循环获取直到页面顶部</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getTop</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> T = e.offsetTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span>(e = e.offsetParent) &#123;</span></span><br><span class="line">                T += e.offsetTop;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> T;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params">imgs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> H = <span class="built_in">document</span>.documentElement.clientHeight;<span class="comment">//获取可视区域高度</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> S = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (H + S &gt; getTop(imgs[i])) &#123;</span></span><br><span class="line"><span class="javascript">                    imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//onscroll()在滚动条滚动的时候触发</span></span></span><br><span class="line">            lazyLoad(imgs);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更加便捷的一个方式就是通过getBoundingClientRect()，通过返回对象的属性bound.top &lt;= clientHeight（window.innerHeight?）进行判断是不是在视口内。</p>
</li>
<li><p>let var const</p>
<p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象，在全局中声明会变成window的属性；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，行为基本与let相同，但是在声明的时候必须要初始化变量，在后面出现的代码中不能再修改该常量的值。</p>
</li>
<li><p>什么是事件循环机制？</p>
<p>了解事件循环机制，首先就要去了解什么是同步异步。</p>
<p>js是单线程的，也就是说在JS引擎中负责解释和执行js代码的线程只有一个（主线程和工作线程之分）</p>
<p>同步是指返回的时候能得到预期的值，而异步是只返回时得不到预期的值。</p>
<p>一个异步过程通常是这样的：</p>
<blockquote>
<p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
</blockquote>
<p>异步函数通常具有以下的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(args..., callbackFn)</span><br></pre></td></tr></table></figure>
<p>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数)<code>A</code></li>
<li>回调函数<code>callbackFn</code></li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。<br><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/3259161542-575018ce29d44_articlex.png"></p>
<p>那么什么是事件循环event loop呢？</p>
<p>事件循环是一种js的执行机制，分为宏任务和微任务。</p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p>
<p>对于宏任务和微任务来说（宏任务一轮循环结束后会在微任务队列中查找）：</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126200149.png"></p>
<p>对于Node.js来说有一些不同</p>
<p>nodejs 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<blockquote>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126202303.png"></p>
<p>梳理一下 nodejs 三个非常重要的执行阶段:</p>
<ol>
<li>执行 <code>定时器回调</code> 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它<code>timer</code>。</li>
<li>轮询(英文叫<code>poll</code>)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、</li>
</ol>
<p>‘connect’等事件使得事件循环到达 <code>poll</code> 阶段。到达了这个阶段后:</p>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li>如果队列<code>不为空</code>，拿出队列中的方法依次执行</li>
<li>如果队列为空，检查是否有 setImmdiate的回调<ul>
<li>有则前往<code>check阶段</code>(下面会说)</li>
<li><code>没有则继续等待</code>，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后<code>自动进入 check 阶段</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>check 阶段。这是一个比较简单的阶段，直接<code>执行 setImmdiate</code> 的回调。</li>
</ol>
<p>当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 <code>I/O异常的回调阶段</code>。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p>
<p>并且在 check 阶段结束后还会进入到 <code>关闭事件的回调阶段</code>。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， ‘close’ 事件的回调就会在这个阶段执行。</p>
</blockquote>
<p>node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。而 node 版本小于 11 的情况下，对于定时器的处理是: 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p>
<p><strong>nodejs 和 浏览器关于eventLoop的主要区别</strong></p>
<p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>中执行的，而nodejs中的微任务是在<code>不同阶段之间</code>执行的。node中process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<code>优先于微任务</code>执行。</p>
</li>
<li><p>函数柯里化</p>
<p>函数柯里化是一种函数的转换，将一个函数从可调用的f（a, b, c）变成可调用的f（a）（b）（c）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123; <span class="comment">// curry(f) 执行柯里化转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = _.curry(sum); <span class="comment">// 使用来自 lodash 库的 _.curry</span></span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3，仍可正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3，以偏函数的方式调用</span></span><br></pre></td></tr></table></figure>
<p>更加高级的原生实现，可以实现正常或者偏函数方式的调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt;= func.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pass</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<p>箭头函数表达式没有自己的this,arguments,super或new.target。</p>
<p>也就是说不绑定this，没有prototype属性，不能用作生成器，用call，apply调用，第一个参数会被忽略。</p>
<p>还有额外的一点就是箭头函数返回对象字面量的时候，要用括号包起来。</p>
</li>
<li><p>对象创建的三种方法</p>
<p>字面量方法：const obj = { }</p>
<p>new：const obj = new Object()</p>
<p>构造函数：通过function关键字加对象名称来创建</p>
</li>
<li><p>数组的方法</p>
<p>toString() 把数组转换为数组值（逗号分隔）的字符串。（如果需要原始值，则 JavaScript 会自动把数组转换为字符串。）</p>
<p>join() 方法也可将所有数组元素结合为一个字符串。</p>
<p>pop() 方法从数组中删除最后一个元素，返回“被弹出”的值。</p>
<p>push() 方法（在数组结尾处）向数组添加一个新的元素，返回新数组的长度。</p>
<p>shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回被“位移出”的字符串。</p>
<p>unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素，返回新数组的长度。</p>
<p>可以使用 JavaScript delete 运算符来<em>删除</em>，会在数组留下undefined。</p>
<p>splice() 方法可用于向数组添加新项，也可以用来删除元素，第二个参数定义了删除多少个元素，返回一个包含已删除项的数组。</p>
<p>concat() 方法通过合并（连接）现有数组来创建一个新数组，可以拼接任意个数组。</p>
<p>slice() 方法用数组的某个片段切出新数组。</p>
<p>还有sort()（可以自定义比值函数）和reverse()</p>
</li>
<li><p>addEventListener和onClick()的区别</p>
<p>一个是js事件绑定，另一个是普通事件。</p>
<p>普通事件就是直接触发事件，同一时间只能指向同一个对象，所以会被覆盖掉。</p>
<p>事件绑定就是对于一个可以绑定的事件对象，进行多次绑定事件都能运行。</p>
<p>addEventListener对任何DOM都是有效的，而onclick仅限于HTML</p>
<p>addEventListener可以控制listener的触发阶段,（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除。</p>
</li>
<li><p>setTimeout用作倒计时为何会产生误差？</p>
<p>如果当前 <strong>执行栈</strong> 所花费的时间大于 <strong>定时器</strong> 时间，那么定时器的回调在 <strong>宏任务(macrotask)</strong> 里，来不及去调用，所有这个时间会有误差。</p>
<p>我们看以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;biubiu&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">某个执行时间很长的函数();</span><br></pre></td></tr></table></figure>
<p>如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 <strong>执行栈</strong> ，要等执行栈执行完毕后再去读取 <strong>微任务(microtask)**，等 **微任务(microtask)</strong> 完成，这个时候才会去读取 <strong>宏任务(macrotask)</strong> 里面的 <strong>setTimeout</strong> 回调函数执行。<strong>setInterval</strong> 同理，例如每3秒放入宏任务，也要等到执行栈的完成。</p>
<p>还有一种情况如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;嘤嘤嘤&#x27;</span>);</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在最新的规范里有这么一句： <strong>If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.</strong></p>
<p>所以意思就是意思就是如果timeout嵌套大于 5层，而时间间隔小于4ms，则时间间隔增加到4ms。</p>
</li>
<li><p>DOM的location对象</p>
</li>
<li><p>call，apply</p>
</li>
<li><p>实现页面加载进度条</p>
</li>
<li><p><code>strict</code>模式</p>
</li>
<li><p>Symbol概念及其作用</p>
</li>
<li><p>Set和Map数据结构</p>
</li>
<li><p>Proxy</p>
</li>
<li><p>Reflect对象</p>
</li>
<li><p>循环语法比较及使用场景（for、forEach、for…in、for…of）</p>
</li>
<li><p>几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"># 面经</a>
              <a href="/tags/Javascript/" rel="tag"># Javascript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/17/Html%E4%B8%8ECss%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/" rel="prev" title="Html与Css面经汇总">
      <i class="fa fa-chevron-left"></i> Html与Css面经汇总
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/" rel="next" title="浏览器相关面经汇总">
      浏览器相关面经汇总 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Zhengyu"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">Chen Zhengyu</p>
  <div class="site-description" itemprop="description">Have a nice day!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cypherss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cypherss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cypher0601@gmail.com" title="E-Mail → mailto:cypher0601@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Zhengyu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">54k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">49 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script color='' opacity='' zIndex='' count='' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://cypher.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/";
    this.page.identifier = "2021/01/17/Javascript面经汇总/";
    this.page.title = "Javascript面经汇总";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://cypher.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
