<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Node面经汇总</title>
    <url>/2021/01/18/Node%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>NodeJS基本概念与特点</li>
<li>CommonJS规范、核心模块</li>
<li>Node的异步I/O</li>
<li>Node的内存控制</li>
<li>Node的构建网络服务（TCP、HTTP、WebSocket服务等）</li>
<li>Node的进程</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>OCEANIA项目文档</title>
    <url>/2021/01/18/OCEANIA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="项目背景-amp-概况"><a href="#项目背景-amp-概况" class="headerlink" title="项目背景&amp;概况"></a>项目背景&amp;概况</h2><p>OCEANIA项目的名字实际上是在线代码依赖分析平台的简写，这个平台的设计初衷是希望可以让开发人员在可视化方面对一个项目的代码规模，大致的依赖调用关系有一个大致的认识。同时项目也维护了一个数据库中的图，保存了完整的项目的代码依赖调用关系，后续对于项目的traceability，代码分析之类的提供便利。项目的大致的应用场景是提供给一个拿到新项目的开发者用来熟悉代码结构或者给管理者去监管代码构成以及开发进展的工具平台</p>
<h2 id="项目的技术栈"><a href="#项目的技术栈" class="headerlink" title="项目的技术栈"></a>项目的技术栈</h2><p>前端使用的是Vue框架配合Antdv，使用了vuex以及VueRouter等技术。</p>
<p>后端使用的是Springboot+Mysql以及Jenkins集成部署，还配合Websocket实现了团队通讯功能。</p>
<p>在代码依赖图可视化方面使用的是Cytoscape.js，这个框架提供了很多遍历边点以及对它们还有画布进行操作的API，同时可以自定义布局，因此为了节省浏览器资源，以及优化渲染的效率，我们在后端实现了一个力导向的layout分析算法（首先计算节点之间的斥力，然后根据联通关系计算引力，然后做一些微调之后更新节点位置，迭代调用这个方法200次），提前计算好节点在图上的布局，传到前端进行渲染。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>OASIS项目文档</title>
    <url>/2021/01/18/OASIS%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>OASIS项目的全称是在线学术图谱系统。项目通过爬虫爬取一些计算机领域的IEEE或者ACM的会议，文章，学者信息，进行处理和可视化操作，可以提供展示和综合查询的便利。</p>
<h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><p>项目采用的是Vue + ElementUI的前端组合，使用了Vue-Router。前端element实现了按需加载，并且遵循ES6的语法进行了模块化处理，可复用性强。</p>
<p>后端SpringBoot + Mysql + Redis构建，通过Gitlab-CI集成管理，数据信息处理方面使用了Stanford-NLP的包。</p>
<p>后端第二阶段实现了微服务架构，拆分了学术实体以及搜索实体两个部分。</p>
<p>爬虫使用的是python。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面经汇总</title>
    <url>/2021/01/18/Vue%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>Vue生命周期</p>
<p><strong>beforeCreate</strong>（创建前） 在数据观测和初始化事件还未开始<br><strong>created</strong>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来<br><strong>beforeMount</strong>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br><strong>mounted</strong>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。<br><strong>beforeUpdate</strong>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br><strong>updated</strong>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。<br>1.什么是vue生命周期？<br>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p>
<p>2.vue生命周期的作用是什么？<br>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<p>3.vue生命周期总共有几个阶段？<br>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p>
<p>4.第一次页面加载会触发哪几个钩子？<br>答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。</p>
<p>5.DOM 渲染在 哪个周期中就已经完成？<br>答：DOM 渲染在 mounted 中就已经完成了。</p>
</li>
<li><p>介绍一下vuex以及使用场景</p>
<p>只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。<br>在main.js引入store，注入。新建了一个目录store，….. export 。<br>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车<br><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/131469924-5931124f9479e.png"></p>
<p><strong>state</strong><br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。<br><strong>mutations</strong><br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。<br><strong>getters</strong><br>类似vue的计算属性，主要用来过滤一些数据。<br><strong>action</strong><br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123; &#x2F;&#x2F;store实例</span><br><span class="line">      state: &#123;</span><br><span class="line">         count: 0</span><br><span class="line">             &#125;,</span><br><span class="line">      mutations: &#123;                </span><br><span class="line">         increment (state) &#123;</span><br><span class="line">          state.count++</span><br><span class="line">         &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">      actions: &#123; </span><br><span class="line">         increment (context) &#123;</span><br><span class="line">          context.commit(&#39;increment&#39;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>modules</strong><br>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const moduleA &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>vue双向绑定的原理</p>
<p>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>vue的数据双向绑定将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 <code>&#123;&#123;&#125;&#125;</code>），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p>
<p><strong>js实现简单的双向绑定</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txt&quot;&gt;</span><br><span class="line">    &lt;p id&#x3D;&quot;show&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var obj &#x3D; &#123;&#125;</span><br><span class="line">    Object.defineProperty(obj, &#39;txt&#39;, &#123;</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return obj</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            document.getElementById(&#39;txt&#39;).value &#x3D; newValue</span><br><span class="line">            document.getElementById(&#39;show&#39;).innerHTML &#x3D; newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    document.addEventListener(&#39;keyup&#39;, function (e) &#123;</span><br><span class="line">        obj.txt &#x3D; e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>vue-router实现原理</p>
</li>
<li><p>vue组件之间的通信</p>
</li>
<li><p>vue的一些新技术</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack面经汇总</title>
    <url>/2021/01/18/Webpack%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>前端工程化的流程</p>
<p>架构选型、业务开发、测试、打包构建、部署上线、项目监控</p>
<p>前端工程化要解决的问题就是制定各项规范，使用合适的前端技术和框架，提高生产效率，提高代码的可测试性，以及使用各种自动化的工具，提升整体开发部署的效率。</p>
</li>
<li><p>Webpack基本概念与配置</p>
<p><code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。</p>
<p>webpack配置中需要理解几个核心的概念<code>Entry</code> 、<code>Output</code>、<code>Loaders</code> 、<code>Plugins</code>、 <code>Chunk</code></p>
<ul>
<li>Entry：指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库</li>
<li>Output：告诉webpack如何命名输出的文件以及输出的目录</li>
<li>Loaders：由于webpack只能处理javascript，所以我们需要对一些非js文件处理成webpack能够处理的模块，比如sass文件</li>
<li>Plugins：<code>Loaders</code>将各类型的文件处理成webpack能够处理的模块，<code>plugins</code>有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。比如对js文件进行压缩优化的<code>UglifyJsPlugin</code>插件</li>
<li>Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用<code>CommonsChunkPlugin</code>将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中<code>CommonsChunkPlugin</code>被废弃，使用<code>SplitChunksPlugin</code></li>
</ul>
<a id="more"></a>
</li>
<li><p>webpack配置文件基本概念</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./app/entry&quot;</span>, <span class="comment">// string | object | array</span></span><br><span class="line">  <span class="comment">// Webpack打包的入口</span></span><br><span class="line">  output: &#123;  <span class="comment">// 定义webpack如何输出的选项</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 所有输出文件的目标路径</span></span><br><span class="line">    filename: <span class="string">&quot;[chunkhash].js&quot;</span>, <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 「入口(entry chunk)」文件命名模版</span></span><br><span class="line">    publicPath: <span class="string">&quot;/assets/&quot;</span>, <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 构建文件的输出目录</span></span><br><span class="line">    <span class="comment">/* 其它高级配置 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;  <span class="comment">// 模块相关配置</span></span><br><span class="line">    rules: [ <span class="comment">// 配置模块loaders，解析规则</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,  <span class="comment">// RegExp | string</span></span><br><span class="line">        include: [ <span class="comment">// 和test一样，必须匹配选项</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">        ],</span><br><span class="line">        exclude: [ <span class="comment">// 必不匹配选项（优先级高于test和include）</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;app/demo-files&quot;</span>)</span><br><span class="line">        ],</span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>, <span class="comment">// 模块上下文解析</span></span><br><span class="line">        options: &#123; <span class="comment">// loader的可选项</span></span><br><span class="line">          presets: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123; <span class="comment">//  解析模块的可选项</span></span><br><span class="line">    modules: [ <span class="comment">// 模块的查找目录</span></span><br><span class="line">      <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">    ],</span><br><span class="line">    extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.css&quot;</span>], <span class="comment">// 用到的文件的扩展</span></span><br><span class="line">    alias: &#123; <span class="comment">// 模块别名列表</span></span><br><span class="line">      <span class="string">&quot;module&quot;</span>: <span class="string">&quot;new-module&quot;</span></span><br><span class="line">	  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// enum</span></span><br><span class="line">  <span class="comment">// 为浏览器开发者工具添加元数据增强调试</span></span><br><span class="line">  plugins: [ <span class="comment">// 附加插件列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>webpack构建流程</p>
<p>webpack 的入口文件其实就实例了<code>Compiler</code>并调用了<code>run</code>方法开启了编译，webpack的编译都按照下面的钩子调用顺序执行。</p>
<ul>
<li>before-run 清除缓存</li>
<li>run 注册缓存数据钩子</li>
<li>before-compile</li>
<li>compile 开始编译</li>
<li>make 从入口分析依赖以及间接依赖模块，创建模块对象</li>
<li>build-module 模块构建</li>
<li>seal 构建结果封装， 不可再更改</li>
<li>after-compile 完成构建，缓存数据</li>
<li>emit 输出到dist目录</li>
</ul>
<p>在webpack <code>make</code>钩子中, <code>tapAsync</code>注册了一个<code>DllEntryPlugin</code>, 就是将入口模块通过调用<code>compilation.addEntry</code>方法将所有的入口模块添加到编译构建队列中，开启编译流程。</p>
<p>随后在<code>addEntry</code> 中调用<code>_addModuleChain</code>开始编译。在<code>_addModuleChain</code>首先会生成模块，最后构建。</p>
<p>在编译完成后，调用<code>compilation.seal</code>方法封闭，生成资源，这些资源保存在<code>compilation.assets</code>, <code>compilation.chunk</code>, 在给webpack写插件的时候会用到.</p>
<p>在<code>seal</code>执行后，便会调用<code>emit</code>钩子，根据webpack config文件的output配置的path属性，将文件输出到指定的path.</p>
<p><strong>总结一下</strong></p>
<ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件。</li>
<li>编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li>
<li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。</li>
<li>输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。</li>
</ol>
</li>
<li><p>webpack的优化问题：</p>
<ol>
<li>打包很慢怎么解决<ol>
<li>优化Loader搜索范围</li>
<li>cache-loader缓存loader处理结果</li>
<li>使用多线程处理打包</li>
<li>将特定的类库提前打包成动态链接库（DllPlugin&amp;DllReferencePlugin）</li>
<li>noParse属性，设置第三方大型类库不需要解析</li>
<li>IgnorePlugin，忽略某些特定的模块</li>
<li>打包文件分析工具</li>
<li>费时分析</li>
<li>文件后缀列表或者路径映射</li>
</ol>
</li>
<li>打包出来的文件很大怎么解决<ol>
<li>对图片进行压缩和优化</li>
<li>删除无用的CSS样式</li>
<li>以CDN方式加载资源</li>
<li>开启Tree Shaking，删除无用代码</li>
<li>开启Scope Hoisting，作用域提升，合并作用域等等</li>
<li>按需加载或者动态加载</li>
</ol>
</li>
</ol>
</li>
<li><p><code>webpack</code>原理之提取公共文件</p>
<p>4.0之前使用CommonsChunkPlugin，4之后使用splitChunks</p>
</li>
<li><p><code>webpack</code> 如何做到 tree shaking</p>
</li>
<li><p>前端模块化的理解</p>
</li>
<li><p>loader和plugin的原理与实现</p>
</li>
<li><p>SPA及其优缺点</p>
</li>
<li><p>SSR实现及优缺点</p>
</li>
<li><p>设计模式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能面经汇总</title>
    <url>/2021/01/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><h2 id="你会用什么工具来查找代码中的性能问题？"><a href="#你会用什么工具来查找代码中的性能问题？" class="headerlink" title="你会用什么工具来查找代码中的性能问题？"></a>你会用什么工具来查找代码中的性能问题？</h2><ol>
<li>Profiler（google调试工具）</li>
<li>Lighthouse（chrome浏览器自带）</li>
<li>eslint检查错误</li>
<li>JSPerf</li>
<li>Dromaeo</li>
<li>Vue developer tools</li>
</ol>
</li>
<li><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>chrome中的develop tool -&gt;source可以进行断点调试，可以参看变量，断点一类的</p>
<a id="more"></a>
</li>
<li><h2 id="增强网站的页面滚动效能"><a href="#增强网站的页面滚动效能" class="headerlink" title="增强网站的页面滚动效能"></a>增强网站的页面滚动效能</h2><ol>
<li><p>不要随便让页面进入合成</p>
</li>
<li><p>防抖节流</p>
</li>
<li><p>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参数，该函数会在重绘前调用。requestAnimationFrame(realFunc);rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器）通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000/60 ，触发频率大概是 16.7ms </p>
</li>
<li><p>避免在scroll 事件中修改样式属性，将样式操作从 scroll 事件中剥离</p>
</li>
<li><p>滑动过程中尝试使用 pointer-events: none 禁止鼠标事件</p>
<p>这是一个css样式，用于禁止鼠标行为，比如hover、click失效，即元素不会变成鼠标事件的target，这样增加滚动是的帧频，特别是移动端的时候。滚动时在body上添加pointer-events: none，停止滚动时就去掉。</p>
</li>
</ol>
</li>
<li><h2 id="重排，重绘，合成"><a href="#重排，重绘，合成" class="headerlink" title="重排，重绘，合成"></a>重排，重绘，合成</h2><h3 id="1-页面的呈现流程"><a href="#1-页面的呈现流程" class="headerlink" title="1. 页面的呈现流程"></a>1. 页面的呈现流程</h3><ol>
<li><p>浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</p>
</li>
<li><p>浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</p>
</li>
<li><p>DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个NODE都有自己的style，而且 render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到 render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。</p>
</li>
<li><p>一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzI3LzE2OTJmMzlkMWZhMTU4NGU.png"></p>
</li>
</ol>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/18293586-6ea6536bed94220b.png"></p>
<h3 id="2-什么是回流与重绘"><a href="#2-什么是回流与重绘" class="headerlink" title="2. 什么是回流与重绘"></a>2. 什么是回流与重绘</h3><ol>
<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</li>
<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</li>
<li>回流必将引起重绘，而重绘不一定会引起回流。</li>
</ol>
<p>repaint，就是浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如我们改变了元素的颜色，加个下划线等。</p>
<p>reflow, 浏览器得知元素产生了对文档树排版有影响的样式变化，对所有受影响的dom节点进行重新排版工作</p>
<h3 id="3-回流发生场景"><a href="#3-回流发生场景" class="headerlink" title="3. 回流发生场景"></a>3. 回流发生场景</h3><p>当页面布局和几何属性改变时就需要回流。</p>
<ol>
<li>添加或者删除可见的DOM元素；</li>
<li>元素位置改变；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li>
<li>页面渲染初始化；</li>
<li>浏览器窗口尺寸改变——resize事件发生时；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; document.body.style;</span><br><span class="line">s.padding &#x3D; &quot;2px&quot;; &#x2F;&#x2F; 回流+重绘</span><br><span class="line">s.border &#x3D; &quot;1px solid red&quot;; &#x2F;&#x2F; 再一次 回流+重绘</span><br><span class="line">s.color &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 再一次重绘</span><br><span class="line">s.backgroundColor &#x3D; &quot;#ccc&quot;; &#x2F;&#x2F; 再一次 重绘</span><br><span class="line">s.fontSize &#x3D; &quot;14px&quot;; &#x2F;&#x2F; 再一次 回流+重绘</span><br><span class="line">&#x2F;&#x2F; 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#39;abc!&#39;));</span><br><span class="line"></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<h3 id="4-回流与重绘的影响"><a href="#4-回流与重绘的影响" class="headerlink" title="4.回流与重绘的影响"></a>4.回流与重绘的影响</h3><p>回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。</p>
<h3 id="5-浏览器如何处理"><a href="#5-浏览器如何处理" class="headerlink" title="5. 浏览器如何处理"></a>5. 浏览器如何处理</h3><p>每句JS操作都去回流重绘的话，浏览器可能就会受不了。</p>
<p><strong>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列：</p>
<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>width,height</li>
<li>请求了getComputedStyle(), 或者 IE的 currentStyle</li>
</ol>
<p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。引擎会重新渲染来确保获取的值 是实时的。</p>
<h3 id="6-如何减少回流与重绘"><a href="#6-如何减少回流与重绘" class="headerlink" title="6. 如何减少回流与重绘"></a>6. 如何减少回流与重绘</h3><p>减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。</p>
<ol>
<li>对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</li>
<li>尽可能在DOM树的最末端改变class。避免设置多层内联样式。将动画效果应用到position属性为absolute或fixed的元素上。避免使用CSS表达式（例如：calc()）。</li>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ol>
<h3 id="7-再次理解display-none-与-visibility-hidden-的异同"><a href="#7-再次理解display-none-与-visibility-hidden-的异同" class="headerlink" title="7. 再次理解display:none 与 visibility:hidden 的异同"></a>7. 再次理解display:none 与 visibility:hidden 的异同</h3><ol>
<li>两者都可以在页面上隐藏节点。<ul>
<li>display:none 隐藏后的元素不占据任何空间。它的宽度、高度等各种属性值都将“丢失”</li>
<li>visibility:hidden 隐藏的元素空间依旧存在。它仍具有高度、宽度等属性值</li>
</ul>
</li>
<li>性能的角度而言，即是回流与重绘的方面。<ul>
<li>display:none 会触发 reflow（回流）</li>
<li>visibility:hidden 只会触发 repaint（重绘），因为没有发现位置变化</li>
</ul>
</li>
</ol>
<p>他们两者在优化中 visibility:hidden 会显得更好，因为我们不会因为它而去改变了文档中已经定义好的显示层次结构了。</p>
<p>​    3. 对子元素的影响</p>
<ul>
<li>display:none 一旦父节点元素应用了 display:none，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何设置 display 值都无法显示；</li>
<li>visibility:hidden 一旦父节点元素应用了 visibility:hidden，则其子孙后代也都会全部不可见。不过存在隐藏“失效”的情况。当其子孙元素应用了 visibility:visible，那么这个子孙元素又会显现出来。</li>
</ul>
<h3 id="8-合成层"><a href="#8-合成层" class="headerlink" title="8. 合成层"></a>8. 合成层</h3></li>
<li><h2 id="Babel原理"><a href="#Babel原理" class="headerlink" title="Babel原理"></a>Babel原理</h2><p>babel通俗的来说是一个js的编译器，本质上babel是通过操作AST抽象语法树来完成代码的转译的。</p>
<p>大多数编译器的工作过程可以分为三部分：</p>
<ol>
<li><p>**Parse(解析)**：将源代码转换成更加抽象的表示方法（例如抽象语法树）</p>
<p>分为两个阶段：词法分析和语法分析</p>
<p>词法分析LA将代码分解为Tokens，然后应用语法分析生成AST</p>
</li>
<li><p>**Transform(转换)**：对（抽象语法树）做一些特殊处理，让它符合编译器的期望</p>
<p>dfs，维护了一个Visitor的对象，匹配一个type就可以调用visitor里的方法获取具体的节点，然后根据一定的规则去替换节点</p>
</li>
<li><p>**Generate(代码生成)**：将第二步经过转换过的（抽象语法树）生成新的代码（dfs）</p>
</li>
</ol>
</li>
</ol>
<ol start="6">
<li><h2 id="实现一个幻灯片功能"><a href="#实现一个幻灯片功能" class="headerlink" title="实现一个幻灯片功能"></a>实现一个幻灯片功能</h2></li>
</ol>
<ol start="7">
<li><h2 id="前端优化方法"><a href="#前端优化方法" class="headerlink" title="前端优化方法"></a>前端优化方法</h2><ol>
<li><p>JS CSS极简化, 减少文件大小</p>
</li>
<li><p>真正意义上将样式，配置逻辑embed到页面中，从而减少http请求。CSS放在头部加载，JS放在尾部加载</p>
</li>
<li><p>图片的压缩, 静态资源 CDN化</p>
</li>
<li><p>视图层使用js模版，或者完整的View框架（React），以Lazyload的形式分块加载</p>
</li>
<li><p>CSS JS选择器ID化，ID选择器是最快的。</p>
</li>
<li><p>PC站点和移动端完全分开，拒绝响应式</p>
</li>
<li><p>活用LocalStorage, 存储用户状态, 组件状态，而非JS或者模板</p>
</li>
<li><p>减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器</p>
</li>
<li><p>前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</p>
</li>
<li><p>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</p>
</li>
<li><p>当需要设置的样式很多时设置 className 而不是直接操作 style</p>
</li>
<li><p>少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作</p>
</li>
<li><p>避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)</p>
</li>
<li><p>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</p>
</li>
</ol>
</li>
<li><h2 id="css3动画和js动画对比"><a href="#css3动画和js动画对比" class="headerlink" title="css3动画和js动画对比"></a><code>css3</code>动画和<code>js</code>动画对比</h2><h3 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>js动画控制能力强，可以在动画博凡过程中对动画进行精细控制，开始、暂停、终止、取消都是可以做到的</li>
<li>动画效果比css3动画丰富，比如曲线运动，冲击闪烁，视差滚动效果，只有js动画才能完成</li>
<li>js动画大多数情况下没有兼容性问题，而css3动画有兼容性问题</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>js动画的复杂度高于css3</li>
<li>js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况</li>
<li>js动画往往需要频繁操作DOM的css属性来实现视觉上的动画效果，这个时候浏览器要不停地执行重绘和重排，这对于性能的消耗是很大的，尤其是在分配给浏览器的内存没那么宽裕的移动端。</li>
</ol>
<h3 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><p>部分情况下浏览器可以对动画进行优化，为什么说部分情况下呢，因为是有条件的：</p>
<ul>
<li>在Chromium基础上的浏览器中</li>
<li>同时CSS动画不触发layout或paint，在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。</li>
</ul>
<blockquote>
<p>在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。<br>为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息，例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。</p>
</blockquote>
</li>
<li><p>部分效果可以强制使用硬件加速 （通过 GPU 来提高动画性能）</p>
</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>运行进程控制较弱，css3动画只能在某些场景下控制动画的暂停与继续，不能在特定的位置添加添加回调函数</li>
<li>js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况</li>
</ol>
<h3 id="css动画比js动画流畅的前提"><a href="#css动画比js动画流畅的前提" class="headerlink" title="css动画比js动画流畅的前提"></a>css动画比js动画流畅的前提</h3><ul>
<li>js在执行一些复杂的任务</li>
<li>css动画比较少或者不触发pain和layout，即重绘和重排，例如通过改变如下属性生成的css动画<ul>
<li>backface-visibility</li>
<li>opacity</li>
<li>perspective （设置元素视图）</li>
<li>perspective-origin</li>
<li>transfrom</li>
</ul>
</li>
<li>部分属性能够启动3D加速和GPU硬件加速，例如使用transform的translateZ进行3D变换时</li>
<li>在Chromium基础上的浏览器中，这个貌似是内核做了优化，当css动画知识改变transfrom和opacity时，整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行),这样css动画渲染不会影响主线程。</li>
</ul>
</li>
<li><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>正向代理就是服务端不知道是哪一个客户端访问的</p>
<p>而反向代理就是客户端不知道是访问的哪一个真实的服务器</p>
</li>
<li><h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h2><p>1）概念</p>
<p>线程：是程序执行流的最小单元，是系统独立调度和分配CPU（独立运行）的基本单位。</p>
<p>进程：是资源分配的基本单位。一个进程包括多个线程。</p>
<p>2）区别</p>
<p>1.线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</p>
<p>2.每个进程都有自己一套独立的资源（数据），供其内的所有线程共享。</p>
<p>3.不论是大小，开销线程要更“轻量级”</p>
<p>4.一个进程内的线程通信比进程之间的通信更快速，有效。（因为共享变量）</p>
<p>3）多线程与多进程<br>多线程：同一时刻执行多个线程。用浏览器一边下载，一边听歌，一边看视频，一边看网页。。。</p>
<p>多进程：同时执行多个程序。如，同时运行YY，QQ，以及各种浏览器。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2021/01/16/%E5%BA%8F/</url>
    <content><![CDATA[<p>“那些看似不起波澜的日复一日，会突然在某一天让人看到坚持的意义。”</p>
]]></content>
  </entry>
  <entry>
    <title>毕设交接文档</title>
    <url>/2021/01/16/%E6%AF%95%E8%AE%BE%E4%BA%A4%E6%8E%A5%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="一、项目概况介绍"><a href="#一、项目概况介绍" class="headerlink" title="一、项目概况介绍"></a>一、项目概况介绍</h2><p>一种基于Node.js的web前端页面风格替换系统设计与实现</p>
<p>在Selenium Web Driver基础上搭建了浏览器自动化架构，从素材网页中提取颜色数据和组件数据，之后进行替换以及优化，然后给出评分，在采集和替换过程中留下了原始CSS数据，给用户提供参考。</p>
<p>系统是通过Node.js实现的，一共实现了三个算法：颜色数据采集算法，组件数据采集算法和风格替换算法。在线系统是由React，Egg.js完成的。</p>
<a id="more"></a>

<h2 id="二、技术综述"><a href="#二、技术综述" class="headerlink" title="二、技术综述"></a>二、技术综述</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>将多各种语言编程的脚本转换为JSON格式的接口请求，通过JSONWP通信协议与各浏览器的WebDriver进行通信，最u后WebDriver通过Http协议和真实浏览器进行通信。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>js服务端执行环境，好处是数据类型和语法与浏览器没有太大的差异，Selenium的执行结果也是通过JSON返回，在Node中不需要做类型转换可以直接使用。</p>
<h3 id="主题色提取算法"><a href="#主题色提取算法" class="headerlink" title="主题色提取算法"></a>主题色提取算法</h3><p>基于文档分析。</p>
<h3 id="页面相似度算法"><a href="#页面相似度算法" class="headerlink" title="页面相似度算法"></a>页面相似度算法</h3><p>Edgar Marca的JS版本并且经过了优化。</p>
<h3 id="保留原始CSS"><a href="#保留原始CSS" class="headerlink" title="保留原始CSS"></a>保留原始CSS</h3><p>通过遍历document.styleSheets对象，并且调整了过滤和迭代语法树的规则，并且借助缓存机制对查找性能进行了优化。</p>
<h3 id="页面美观程度评估"><a href="#页面美观程度评估" class="headerlink" title="页面美观程度评估"></a>页面美观程度评估</h3><p>AIM独立部署，并且通过WebSocket通信。</p>
<h3 id="平台构建相关技术"><a href="#平台构建相关技术" class="headerlink" title="平台构建相关技术"></a>平台构建相关技术</h3><p>Egg.js 以Koa为基础，进行了性能的强化，然后通过与MongoDB组合，实现了在线平台的构建。</p>
<p>前端使用了React生态进行展示，React通过对虚拟DOM进行处理，来完成对真实DOM的更新工作。（React服务端渲染）</p>
<h2 id="三、系统分析、设计与实现"><a href="#三、系统分析、设计与实现" class="headerlink" title="三、系统分析、设计与实现"></a>三、系统分析、设计与实现</h2><h3 id="系统分析设计"><a href="#系统分析设计" class="headerlink" title="系统分析设计"></a>系统分析设计</h3><p>在论文中有详细的图标展示，在这里不再赘述。</p>
<h3 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h3><p>颜色/组件采集过程：通过构建两个runner，初始化driver对象并且进行相应的配置。</p>
<p>颜色替换算法采用遍历页面中所有元素并且进行统计，最后再计算各项指标的占比情况。（文档分析方法）；</p>
<p>组件提取算法则是通过首先获取原始css然后对页面执行分割算法（Block-o-Matic），然后构建虚拟DOM树转换成JSON对象返回Node.js端并且分解出片段得到组件数据。同时在展示的时候需要将DOM树片段重新还原成HTML片段。</p>
<p>组件替换算法首先建立对原始页面的虚拟DOM的构建，接着通过相似度算法（Thamme Gowda）进行匹配，最后完成替换。替换完成之后在前端展示中将DOM树重新还原成HTML片段。</p>
<p>颜色替换算法则是随机建立匹配，并且在替换完之后进行优化更改背景色或是调整内容溢出。</p>
<h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>目前能够完成的是基本web语言编写出的页面的颜色和组件的替换，但是仍然有大量的可以改进的空间。</p>
<p>首先是现在很多的前端开发都是使用DSL开发，例如各种框架，或者是Typescript等等，因此第一个改进方向就是替换后的组件能够变成DSL语言。</p>
<p>其次现在替换的结果是完全静态网页，一个HTML页面，而忽略了动态的js交互等等，因为在内容被修改后，JS就已经失效了。那么在后续的工作中，也就是第二个改进方向，就是替换之后能够保留动态的交互效果。为了实现这个方向，可能需要用户对工程化文件做一些修改，例如在webpack阶段load一个插件，暴露一个接口，后期替换的时候可以通过这个接口将所有的样式在源代码上直接替换。</p>
<p>第三个改进方向就是改进替换的效果。例如寻找更加合适的分割算法或者相似度计算算法等等。</p>
<p>第四个方向就是做成一个IDE供开发人员使用，这个方向更偏向工程一些，例如如何页面嵌入一个在线代码编辑器等等。</p>
<p>团队功能：整个替换流程的共享，组件库的共享。</p>
<p>算法方面：结构替换，组件替换，速度上的优化（xpath），语义化。</p>
<p>后端方面：Node + Java</p>
<p>核心改进：针对专业开发人员，提升工作效率。能够在替换完成之后提供源代码，并且提供个性化修改功能。</p>
]]></content>
      <tags>
        <tag>项目</tag>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器相关面经汇总</title>
    <url>/2021/01/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>浏览器输入url之后做了什么？</p>
<p>通过三张图去理解</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210128204022.png"></p>
<a id="more"></a>

<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210128204034.png"></p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210128204044.png"></p>
</li>
<li><p>xss具体</p>
<p><code>XSS</code> 全称是 <code>Cross Site Scripting</code>(即<code>跨站脚本</code>)</p>
<p><code>XSS</code> 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为<code>存储型</code>、<code>反射型</code>和<code>文档型</code>。可以做到：</p>
<ol>
<li>窃取<code>Cookie</code>。</li>
<li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li>
<li>修改 DOM 伪造登录表单。</li>
<li>在页面中生成浮窗广告。</li>
</ol>
<p>防范的措施包括:</p>
<ul>
<li>一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。</li>
<li>两个利用: 利用 CSP，利用 Cookie 的 HttpOnly 属性。</li>
</ul>
</li>
<li><p>csrf具体</p>
<p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p>
<p><code>CSRF</code>攻击一般会有三种方式:</p>
<ul>
<li>自动 GET 请求</li>
<li>自动 POST 请求</li>
<li>诱导点击发送 GET 请求。</li>
</ul>
<p>防范措施: <code>利用 Cookie 的 SameSite 属性</code>、<code>验证来源站点</code>和<code>CSRF Token</code>。</p>
</li>
<li><p>浏览器缓存</p>
<p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p>
<ul>
<li>如果强缓存可用，直接使用</li>
<li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新<ul>
<li>若资源更新，返回资源和200状态码</li>
<li>否则，返回304，告诉浏览器直接从缓存获取资源</li>
</ul>
</li>
</ul>
<p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p>
<ul>
<li>Service Worker离线缓存</li>
<li>Memory Cache内存</li>
<li>Disk Cache磁盘</li>
<li>Push Cache推送缓存</li>
</ul>
</li>
<li><p>浏览器本地存储</p>
<p>浏览器的本地存储主要分为<code>Cookie</code>、<code>WebStorage</code>和<code>IndexedDB</code>, 其中<code>WebStorage</code>又可以分为<code>localStorage</code>和<code>sessionStorage</code>。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补<code>HTTP</code>在<strong>状态管理上的不足</strong>。</p>
<p><code>HTTP</code> 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？</p>
<p>这种背景下，就产生了 <code>Cookie</code>.</p>
<p>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的<code>Application</code>这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p>
<p>Cookie 的作用很好理解，就是用来做<strong>状态存储</strong>的，但它也是有诸多致命的缺陷的：</p>
<ol>
<li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li>
<li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</li>
<li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><h4 id="和Cookie异同"><a href="#和Cookie异同" class="headerlink" title="和Cookie异同"></a>和Cookie异同</h4><p><code>localStorage</code>有一点跟<code>Cookie</code>一样，就是针对一个域名，即在同一个域名下，会存储相同的一段<strong>localStorage</strong>。</p>
<p>不过它相对<code>Cookie</code>还是有相当多的区别的:</p>
<ol>
<li>容量。localStorage 的容量上限为<strong>5M</strong>，相比于<code>Cookie</code>的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。</li>
<li>只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的<strong>性能问题</strong>和<strong>安全问题</strong>。</li>
<li>接口封装。通过<code>localStorage</code>暴露在全局，并通过它的 <code>setItem</code> 和 <code>getItem</code>等方法进行操作，非常方便。</li>
</ol>
<h4 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h4><p>接下来我们来具体看看如何来操作<code>localStorage</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;1&quot;</span>); </span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;info&quot;</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>
<p>接着进入相同的域名时就能拿到相应的值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，<code>localStorage</code>其实存储的都是字符串，如果是存储对象需要调用<code>JSON</code>的<code>stringify</code>方法，并且用<code>JSON.parse</code>来解析成对象。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用<code>localStorage</code>的较大容量和持久特性，可以利用<code>localStorage</code>存储一些内容稳定的资源，比如官网的<code>logo</code>，存储<code>Base64</code>格式的图片资源，因此利用<code>localStorage</code></p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><code>sessionStorage</code>以下方面和<code>localStorage</code>一致:</p>
<ul>
<li>容量。容量上限也为 5M。</li>
<li>只存在客户端，默认不参与与服务端的通信。</li>
<li>接口封装。除了<code>sessionStorage</code>名字有所变化，存储方式、操作方式均和<code>localStorage</code>一样。</li>
</ul>
<p>但<code>sessionStorage</code>和<code>localStorage</code>有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分<code>sessionStorage</code>就不复存在了。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。</li>
<li>可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用<code>sessionStorage</code>就再合适不过了。事实上微博就采取了这样的存储方式。</li>
</ol>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p><code>IndexedDB</code>是运行在浏览器中的<code>非关系型数据库</code>, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p>
<p>除了拥有数据库本身的特性，比如<code>支持事务</code>，<code>存储二进制数据</code>，还有这样一些特性需要格外注意：</p>
<ol>
<li>键值对存储。内部采用<code>对象仓库</code>存放数据，在这个对象仓库中数据采用<strong>键值对</strong>的方式来存储。</li>
<li>异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。</li>
<li>受同源策略限制，即无法访问跨域的数据库。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>计网与操作系统面经汇总</title>
    <url>/2021/01/18/%E8%AE%A1%E7%BD%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>TCP/IP协议分层</p>
<p>TCP/IP按照层次从上至下分为四层：应用层，传输层，网络层，数据链路层。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210128191514.png"></p>
<a id="more"></a>

<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210128191534.png"></p>
</li>
<li><p>三次握手四次挥手机制及原因</p>
<p><strong>三次握手</strong></p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210128200511.png"></p>
<p>不是两次的原因是无法确认客户端的接受能力，可能会造成连接资源的浪费。</p>
<p>不是四次或者更多的原因就是太多了没有必要，三次就足够了。</p>
<p><strong>四次挥手</strong></p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210128201125.png"></p>
<p>等待2MSL的原因是防止服务端数据包没有传输完</p>
<ul>
<li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</li>
<li>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</li>
</ul>
<p>不是三次是可能中间服务端传数据造成的延迟会让客户端重新发送FIN请求</p>
</li>
<li><p>HTTP方法</p>
<p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p>
<ul>
<li>GET: 通常用来获取资源</li>
<li>HEAD: 获取资源的元信息</li>
<li>POST: 提交数据，即上传数据</li>
<li>PUT: 修改数据</li>
<li>DELETE: 删除资源(几乎用不到)</li>
<li>CONNECT: 建立连接隧道，用于代理服务器</li>
<li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li>
<li>TRACE: 追踪请求-响应的传输路径</li>
</ul>
</li>
<li><p>GET和POST的区别</p>
<p>首先最直观的是语义上的区别。</p>
<p>而后又有这样一些具体的差别:</p>
<ul>
<li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>
<li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li>
<li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>
</li>
<li><p>HTTP建立持久连接的意义</p>
<p>每次建立连接的时候都要经过三次握手等必须的程序，如果我们拥有一条可以一直使用的连接的话，也就意味着我们只需要进行一次连接的建立，这就省去了每次建立连接的时间。</p>
<p> 现在很多方案都会采用<strong>持久连接+新连接结合</strong>的方式，这种方式尽可能的减少了新建连接的浪费，同时当现有连接没有办法满足需求的时候，可以建立新连接满足需求，比较灵活。现有的持久连接类型有两种：<strong>HTTP/1.0+的keep-alive和HTTP/1.1的persistent.</strong></p>
</li>
<li><p>HTTP报文的结构</p>
<p>对于 TCP 而言，在传输的时候分为两个部分:TCP头和数据部分。</p>
<p>而 HTTP 类似，也是header + body的结构，具体而言: （起始行 + 头部）报文首部 + 空行 + 实体（报文主体）</p>
<p><strong>起始行</strong></p>
<p>对于请求报文来说，起始行类似下面这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>
<p>也就是<strong>方法 + 路径 + http版本</strong>。</p>
<p>对于响应报文来说，起始行一般张这个样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>响应报文的起始行也叫做<code>状态行</code>。由<strong>http版本、状态码和原因</strong>三部分组成。</p>
<p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p>
<p><strong>头部</strong></p>
<ul>
<li><ol>
<li>字段名不区分大小写</li>
</ol>
</li>
<li><ol>
<li>字段名不允许出现空格，不可以出现下划线<code>_</code></li>
</ol>
</li>
<li><ol>
<li>字段名后面必须<strong>紧接着<code>:</code></strong></li>
</ol>
</li>
</ul>
<p><strong>空行</strong></p>
<p>空行是用来区分头部和实体的。</p>
<p><strong>实体</strong></p>
<p>实体就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。</p>
</li>
<li><p>HTTP状态码</p>
<p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p>
<ul>
<li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</li>
<li><strong>2xx</strong>: 表示成功状态。</li>
<li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</li>
<li><strong>4xx</strong>: 请求报文有误。</li>
<li><strong>5xx</strong>: 服务器端发生错误。</li>
</ul>
<p>接下来就一一分析这里面具体的状态码。</p>
<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p><strong>101 Switching Protocols</strong>。在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p>
<h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p><strong>200 OK</strong>是见得最多的成功状态码。通常在响应体中放有数据。</p>
<p><strong>204 No Content</strong>含义与 200 相同，但响应头后没有 body 数据。</p>
<p><strong>206 Partial Content</strong>顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p>
<h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p><strong>301 Moved Permanently</strong>即永久重定向，对应着<strong>302 Found</strong>，即临时重定向。</p>
<p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p>
<p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p>
<p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。详见<a href="http://47.98.159.95/my_blog/perform/001.html">浏览器缓存</a></p>
<h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><p><strong>400 Bad Request</strong>: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p>
<p><strong>403 Forbidden</strong>: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p>
<p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p>
<p><strong>405 Method Not Allowed</strong>: 请求方法不被服务器端允许。</p>
<p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。</p>
<p><strong>408 Request Timeout</strong>: 服务器等待了太长时间。</p>
<p><strong>409 Conflict</strong>: 多个请求发生了冲突。</p>
<p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大。</p>
<p><strong>414 Request-URI Too Long</strong>: 请求行里的 URI 太大。</p>
<p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p>
<p><strong>431 Request Header Fields Too Large</strong>请求头的字段内容太大。</p>
<h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><p><strong>500 Internal Server Error</strong>: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p>
<p><strong>501 Not Implemented</strong>: 表示客户端请求的功能还不支持。</p>
<p><strong>502 Bad Gateway</strong>: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p>
<p><strong>503 Service Unavailable</strong>: 表示服务器当前很忙，暂时无法响应服务。</p>
</li>
<li><p>Web服务器及其组成</p>
<p>Web系统由客户端（浏览器）和服务器端两部分组成。Web系统架构也被称为B/S架构。最常见的Web服务器有Apache、IIS等，常用的浏览器有IE、Firefox、chrome等。当你想访问一个网页时，需要在浏览器的地址栏中输入该网页的URL地址，或者是通过超链接链接到该网页。浏览器会向该网页所在的服务器发送一个HTTP请求，服务器会对接收到的请求信息进行处理，然后将处理的结果返回给浏览器，最终将浏览器处理后的结果呈现给用户。</p>
</li>
<li><p>HTTP报文首部</p>
<p>除了之前提到的起始行，还有通用首部字段，请求首部字段，响应首部字段，实体首部字段等等</p>
</li>
<li><p>HTTP通用首部字段</p>
<p>Cache-Control：操作缓存的工作机制</p>
<p>Connection：控制不再转发的首部字段；管理持久连接（close，keep-alive）</p>
<p>Date：明确创建报文的日期和时间</p>
<p>Pragma：历史遗留字段（为了兼容版本）</p>
<p>Trailer：分块传输编码</p>
<p>Transfer-Encoding：规定了传输报文主题时采用的编码方式</p>
<p>Upgrade：检测是否可以使用更高版本进行通信（可以就返回101 switching protocols）</p>
<p>Via：追踪客户端与服务器之间的请求和响应报文的传输路径</p>
<p>Warning：从Retry-After演变而来，告知用户一些与缓存相关的警告</p>
</li>
<li><p>HTTP请求首部字段、响应首部字段、实体首部字段</p>
<ol>
<li><p>请求首部字段：</p>
<p>1、Accept</p>
<p> Accept首部可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级</p>
<p> Accept：text/html, application/xhtml+xml, application/xml; q=0.9, <em>/</em>; q=0.8<br>2、Accept-Charset</p>
<p> 用来通知服务器用户代理支持的字符集及字符集的相对优先顺序</p>
<p> Accept-Charset： iso-8859-5，unicode-1-1；q=0.8<br>3、Accept-Encoding</p>
<p> 用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序</p>
<p> Accept-Encoding：gzip，deflate<br>4、Accept-Language</p>
<p> 告知服务器用户代理支持的自然语言集及自然语言集的优先级</p>
<p> Accept-Language：zh-cn，zh；q=0.7，en-us，en；q=0.3<br>5、Authorization</p>
<p> 告知服务器用户代理的认证信息，通常，想要通过服务器认证的用户代理在接收到返回的401状态码响应后，把首部字段Authorization加入到请求中。</p>
<p> Authorization：Basic dwvub……..<br>6、Expect</p>
<p> 客户端使用首部字段Expect字段来告知服务器，期待出现的某种特定行为</p>
<p> 等待状态码100响应的客户端在发生请求时，需要指定Expect: 100-continue</p>
<p> Expect: 100-continue<br>7、Form</p>
<p> 用来告知服务器使用用户代理的用户的电子邮件地址</p>
<p> Form：2294***<br> 272@qq.com<br>8、Host</p>
<p> 用来告知服务器，请求的资源所在的互联网主机名和端口号,Host首部字段在HTTP/1.1规范内唯一一个必须包含在请求内的首部字段<br>9、If-Match</p>
<p> 形如If-***这种样式的请求首部字段，都可称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求，服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。</p>
<p> If-Match：“123456”<br>10、If-Modified-Since</p>
<p> 首部字段If-Modified-Since，属附带条件之一，会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指定If-Modified-Since字段值的日期之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified的响应。<br>11、If-None-Match</p>
<p> 首部字段If-None-Match属于附带条件之一，它和首部字段If-Match作用相反，用于指定If-None-Match字段值的实体标记（ETag）值与请求资源的ETag不一致时，就告知服务器处理该请求，可获得最新的资源。<br>12、If-Range</p>
<p> 首部字段If-Range属于附带条件之一，告知服务器若指定的If-Range字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理，反之，则返回全体资源。</p>
<p> GET /index.html</p>
<p> If-Range:”123456”</p>
<p> Range: bytes=5001-10000<br>13、If-Unmodified-Since</p>
<p> 首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反，它的作用是告知服务器，指定的请求资源只有在字段内指定的日期之后，未发生更新的情况下，才能处理请求。如果在指定日期后发生了更新，则以状态码412 Precondition Failed作为响应返回</p>
<p> If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT<br>14、Max-Forwards</p>
<p> 通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值、当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应。</p>
<p> Max-Forwards：10<br>15、Proxy-Authorization</p>
<p> 接收到代理服务器发来的认证质疑时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息。</p>
<p> 这个行为是与客户端和服务器之间的HTTP访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间，客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。<br>16、Range</p>
<p> 对于只获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围。接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应，无法处理该范围请求时，则会返回状态码200 OK的响应及全部字段。</p>
<p> Range：bytes=5001-10000<br>17、Referer</p>
<p> 首部字段Referer会告知服务器请求的原始资源的URI<br>18、TE</p>
<p> 首部字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级，它和首部字段Accept-Encoding的功能很相像，但是用于传输编码。</p>
<p> TE：gzip，deflate；q=0.5<br>19、User-Agent</p>
<p> 首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器</p>
<p> User-Agent：Mozilla/5.0 (Windows NT 6.1; WOW64;rv:13.0) Gecko/=&gt;20100101 Firefox/13.0.1</p>
</li>
<li><p>响应首部字段</p>
<p>1、Accept-Ranges<br>是否接受字节范围请求(是否能处理范围请求，以指定获取服务器端资源的某个部分。)</p>
<p>字段值有bytes与none</p>
<p>2、Age<br>推算资源创建经过时间</p>
<p>3、ETag<br>资源的匹配信息</p>
<p>首部字段 ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。</p>
<p>另外，当资源更新时，ETag值也需要更新。生成 Etag值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p>
<p>应用：比如中文版/英文版对应的资源。两者的URI是相同的，所以仅凭 URI指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag值来指定资源。(范围请求，查看资源是否更新时，对比ETag)</p>
<p>强ETag值和弱ETag值</p>
<p>强 ETag值，不论实体发生多么细微的变化都会改变其值。</p>
<p>ETag: “usagi-1234”<br>弱 ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag值。这时，会在字段值最开始处附加 W/。</p>
<p>ETag: W/“usagi-1234”<br>4、Location<br>令客户端重定向至指定URI</p>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>
<p>配合3xx：Redirection 的响应，提供重定向的URI</p>
<p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p>5、Proxy-Authenticate<br>代理服务器对客户端的认证信息</p>
<p>6、Retry-After<br>对再次发起请求的时机要求</p>
<p>首部字段Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。</p>
<p>7、Server<br>Server 首部包含了处理请求的源头服务器所用到的软件相关信息。</p>
<p>应该避免使用过长或者过于详细的描述作为 Server 的值，因为这有可能泄露服务器的内部实现细节，有利于攻击者找到或者探测已知的安全漏洞。</p>
<p>8、Vary<br>代理服务器缓存的管理信息</p>
<p>Vray是一个HTTP响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。它被服务器用来表明在 content negotiation algorithm（内容协商算法）中选择一个资源代表的时候应该使用哪些头部信息（headers）</p>
<p>当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Vary 首部字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回。</p>
<p>9、WWW-Authenticate<br>服务器对客户端的认证信息</p>
</li>
<li><p>实体首部字段</p>
<p>1、Allow</p>
<p> 首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应，与此同时，还会把所有能支持的HTTP方法写入首部字段Allow返回</p>
<p> 如：Allow：GET，HEAD<br>2、Content-Encoding</p>
<p> 首部字段Content-Encoding会告知服务器对实体的主体部分选用的内容编码方式。有gzip、compress、deflate、identity</p>
<p> 如：Content-Encoding：gzip<br>3、Content-Language</p>
<p> Content-Language会告知客户端，实体主体所使用的自然语言</p>
<p> 如：Content-Language：zh-CN<br>4、Content-Length</p>
<p> Content-Length表明了实体主体部分的大小，单位是字节</p>
<p> 如：Content-Length：15000<br>5、Content-Location</p>
<p> Content-Location给出与报文主体部分相对应的URI<br>6、Content-MD5</p>
<p> Content-MD5是一串由MD5算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达</p>
<p> 如：Content-MD5：*<strong>**</strong><br>7、Content-Range</p>
<p>针对范围请求，返回响应时使用的首部字段Content-Range，告知客户端作为响应返回的实体的哪个部分符合范围请求，以字节为单位，表示当前发送部分及整体实体大小</p>
<p> 如：Content-Range：bytes 5001-10000/10000<br>8、Content-Type</p>
<p> 说明实体主体内对象的媒体类型</p>
<p> 如：Content-Type：text/html; charset=UTF-8<br>9、Expires</p>
<p>将资源失效的日期告诉客户端</p>
<p> 如：Expires：Wed，04 Jul 2012 08:26:05 GMT<br>10、Last-Modified</p>
<p>指明资源最终修改的时间</p>
<p>如：Last-Modified：Wed，04 Jul 2012 08:26:05 GMT</p>
</li>
<li><p>总结一下就是</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210129165110.png"></p>
</li>
</ol>
</li>
<li><p>Cookie相关首部字段</p>
<p>为cookie服务的首部字段有Set-Cookie，以及Cookie</p>
<p>其中Set-Cookie有expires，path，domain，secure，HttpOnly属性。</p>
</li>
<li><p>HTTPS与HTTP区别</p>
<h3 id="HTTP与HTTPS介绍"><a href="#HTTP与HTTPS介绍" class="headerlink" title="HTTP与HTTPS介绍"></a>HTTP与HTTPS介绍</h3><p>​    超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>​    为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>​    HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全</p>
<p>​    HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h3 id="HTTPS和HTTP的主要区别"><a href="#HTTPS和HTTP的主要区别" class="headerlink" title="HTTPS和HTTP的主要区别"></a>HTTPS和HTTP的主要区别</h3><p>​    1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>​    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。</p>
<p>​    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>​    4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
</li>
<li><p>Cookie与Session</p>
<p><strong>cookie是什么</strong><br>一个HTTP cookie的（网络Cookie，浏览器cookie）是一小片数据的一个服务器发送到用户的网络浏览器。浏览器可以存储它并将其与下一个请求一起发送回同一服务器。通常，它用于判断两个请求是否来自同一个浏览器 - 例如，保持用户登录。它记住无状态 HTTP协议的有状态信息。</p>
<p><strong>session是什么</strong><br>客户端请求服务端，服务端（Tomcat）会为这次请求开辟一块内存空间，这个对象便是Session对象， 存储结构为ConcurrentHashMap。</p>
<p>session的目的：弥补HTTP无状态特性，服务器可以利用session存储客户端在同一个会话期间的一些操作记录。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210129165615.png"></p>
</li>
<li><p>基于HTTP的功能追加协议（AJAX、SPDY、WebSocket）</p>
<p>1、HTTP的一些标准会成为HTTP性能上的瓶颈：</p>
<p>一条连接上只可发送一个请求。</p>
<p>请求只能从客户端开始，客户端不可以接收除响应以外的指令。</p>
<p>请求/响应首部未经压缩就发送，首部信息越多延迟越大。</p>
<p>发送冗长的手部，每次互相发送相同的首部造成的浪费较多。</p>
<p>可任意选择数据压缩格式，非强制压缩发送。</p>
<p>2、Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）是一种有效利用JavaScript和DOM（Document Object Model，文档对象模型）的操作，以达到局部Web页面替换加载的异步通信手段。由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。</p>
<p>3、SPDY：Google在2010年发布，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间。SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时考虑到安全性问题，SPDY规定通信中使用SSL。</p>
<p>使用SPDY后，HTTP协议额外获得的功能：</p>
<p>多路复用（通过单一的TCP连接，可以无限制处理多个HTTP请求。）</p>
<p>赋予请求优先级：可以给请求逐个分配优先级顺序，这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p>
<p>压缩HTTP首部：这样通信产生的数据包数量和发送的字节数就更少了。</p>
<p>推送功能：支持服务器主动向客户端推送数据的功能。</p>
<p>服务器提示功能：服务器可以主动提示客户端请求所需的资源，由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p>
<p>4、WebSocket：使用浏览器进行全双工通信。</p>
<p>WebSocket是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<p>WebScoket协议的主要特点：</p>
<p>推送功能：支持服务器想客户端推送数据的推送功能。</p>
<p>减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态，和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。</p>
</li>
<li><p>常见的Web攻击分类</p>
<p>常见的有XSS，CSRF，SQL注入攻击，文件上传漏洞，DDos/Dos攻击（第一个多一个分布式，都是拒绝服务攻击，通过大量同时攻击，导致目标无法正常使用）</p>
</li>
<li><p>TCP与UDP区别</p>
<p><strong>TCP是一个面向连接的、可靠的、基于字节流的传输层协议。</strong></p>
<p>而<strong>UDP是一个面向无连接的传输层协议。</strong>(就这么简单，其它TCP的特性也就没有了)。</p>
<p>具体来分析，和 <code>UDP</code> 相比，<code>TCP</code> 有三大核心特性:</p>
<ol>
<li><p><strong>面向连接</strong>。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p>
</li>
<li><p><strong>可靠性</strong>。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。</p>
<p>TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是<strong>有状态</strong>。</p>
<p>当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是<strong>可控制</strong>。</p>
<p>相应的，UDP 就是<code>无状态</code>, <code>不可控</code>的。</p>
</li>
<li><p><strong>面向字节流</strong>。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</p>
</li>
</ol>
</li>
<li><p>为什么传统上利用多个域名来提供网站资源会更有效</p>
<ol>
<li>突破浏览器的并发限制<br>现阶段各大浏览器的同一域名最大的并发请求数量在6个或以上，低版本的IE6、7是2个。</li>
<li>节约cookie带宽<br>在访问服务器时，cookie也会占用一定的带宽，使用多个域名进行分流。</li>
<li>CDN缓存更方便<br>多个域名可以更快速的给客户端分配最优下载服务器，传输数据更快。</li>
<li>防止不必要的安全问题，例如cookie的隔离<br>客户端对服务器进行请求时，发送数据到达的地址会用一个第三方的域名。防止上传恶意数据对cookie进行窃取。</li>
<li>节约主机域名连接数，优化页面响应速度<br>这个很显然，每个域名所响应的客户端请求越少，反应时间也就越短，客户端页面可以更快下载数据。</li>
</ol>
</li>
<li><p><code>Long-Polling</code>、<code>Websockets</code> 和 <code>Server-Sent Event</code></p>
<p>long-polling：浏览器通过HTTP发送一个带有接收者ID（这里是user）的请求和当前状态（当前展示的未读通知的数量）到服务器。这将创建一个进程，这个进程一直查询数据库直到状态改变为止，当状态改变的时候，客户端就收到了服务器的相应，它可以更新自己的展示，而后发出下一个请求。</p>
<p>WebSockets：客户端通知WebSockets服务器一个事件，告诉他接收者id，服务器将立即通知消息，当任何新的未读消息来的时候，服务器都将立即返回数据给客户端。</p>
<p>Server-Sent Event：浏览器通过HTTP向服务器发送请求，服务器端拿出数据库中的最新的信息，立即返回给客户端，客户端等待三秒后再次发出下一个请求。</p>
</li>
<li><p>和缓存有关的<code>HTTP</code>首部字段</p>
<p>相当重要。如何应用的？</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210130131802.png"></p>
</li>
<li><p><code>https</code> 加密过程</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210130133938.png"></p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210130133944.png"></p>
</li>
<li><p><code>http2</code>新特性</p>
<p>对于性能的提升主要是两点：头部压缩和多路复用</p>
<p>新功能的实现：设置请求优先级，服务器推送</p>
<p><strong>头部压缩</strong></p>
<p>针对头部字段，使用HPACK压缩算法对请求头进行压缩（核心思想就是通过索引表之类）</p>
<p><strong>多路复用</strong></p>
<p>通过二进制分帧来解决了HTTP的队头阻塞问题</p>
<p><strong>服务器推送</strong></p>
<p>另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E6%88%AA%E5%9B%BE20210130134608.png"></p>
</li>
<li><p>常见的git指令</p>
<p>git add .  #添加改动的文件<br>git commit #（提交至本地）<br>git pull –rebase #（将服务器项目与本地项目合并）<br>git push  #（将本地项目上传至远端库）<br>（在提交前要git pull –rebase 一下，确保当前的本地的代码为最新。）</p>
</li>
<li><p>linux相关指令</p>
<p>ls/cd/pwd/rm/mv/cp/cat/find/whereis等等</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Html与Css面经汇总</title>
    <url>/2021/01/17/Html%E4%B8%8ECss%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li><p>DOCTYPE的作用是什么？</p>
<p>DOCTYPE是document type (文档类型) 的缩写。<code>&lt;!DOCTYPE &gt;</code>声明位于文档的最前面，处于标签之前，它不是html标签。主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。不存在这个声明会导致HTML或XHTML以混杂模式出现，把如何渲染的权力交给了浏览器。</p>
<p>P.S. 严格模式和混杂模式都是浏览器的呈现模式，浏览器究竟使用混杂模式还是严格模式呈现页面与网页中的DTD（文件类型定义）有关，DTD里面包含了文档的规则。比如：loose.dtd</p>
<p><strong>严格模式：</strong>又称标准模式，是指浏览器按照W3C标准来解析代码，呈现页面</p>
<p><strong>混杂模式：</strong>又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面。<br>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<a id="more"></a>
</li>
<li><p><code>&lt;a&gt;&lt;/a&gt;</code>标签的全部作用</p>
<p>标签的target属性大致有这几种：<br>（1）_blank<br>（2）_self<br>（3）_parent<br>（4）_top</p>
<p>————————作用1：超链接——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>在一个新的窗口打开连接相应的网页。</span><br><span class="line"></span><br><span class="line">2、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>在原来的窗口打开连接相应的网页。（如果target属性值不写的话，默认是这种方式）</span><br><span class="line"></span><br><span class="line">3、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">4、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>————————作用2：锚点——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;runtop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">通过<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#runtop&quot;</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>能够实现一个常见的返回顶部的功能。</span><br></pre></td></tr></table></figure>
<p>————————作用3：打电话或者发邮件——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:123456&quot;</span>&gt;</span>打电话给号码为123456的人<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:123456@789.com&quot;</span>&gt;</span>发邮件给给号码为123456@789.com的人<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>————————作用4：协议限定符——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&quot;</span>强制运行的<span class="attr">javascript</span>代码&quot;)&quot;&gt;</span>这样就能够在<span class="tag">&lt;<span class="name">a</span>&gt;</span>标签被点击的时候强制运行href属性里面的代码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">这里的href=&quot;javascript:;&quot;，其中javascript:是伪协议，它可以让我们通过一个链接来调用javascript函数.而采用这个方式 javascript:;可以实现A标签的点击事件运行时，如果页面内容很多，有滚动条时，页面不会乱跳，用户体验更好。</span><br></pre></td></tr></table></figure></li>
<li><p>使用data-属性的好处是什么？</p>
<p>data-* 属性是 HTML 5 的新特性，允许用户在 DOM 中存储自定义信息。</p>
<p>以前，需要存储含有特定含义的信息通常是通过 class 完成的，但这并不是 class 本来的用途。现在，利用 HTML 5，可以为元素添加<code>data-*</code>属性，从而存储自定义信息。其中<code>*</code>是可以自定义的部分。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">id</span>=<span class="string">&quot;tu&quot;</span> <span class="attr">data-category</span>=<span class="string">&quot;Web Development&quot;</span> <span class="attr">data-author</span>=<span class="string">&quot;1&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过 JavaScript 访问自定义的信息有两种方式：<code>getAttribute()</code>和<code>dataset</code>。</p>
<h3 id="getAttribute-方法"><a href="#getAttribute-方法" class="headerlink" title="getAttribute 方法"></a>getAttribute 方法</h3><p>这就是经典的取得一个元素属性的方式，和以前一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;tu&#x27;</span>).getAttribute(<span class="string">&#x27;data-category&#x27;</span>); <span class="comment">// &quot;Web Development&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="dataset-方法"><a href="#dataset-方法" class="headerlink" title="dataset 方法"></a>dataset 方法</h3><p>这是 HTML 5 新增的方法，可以更方便的读取所有的 data 信息。并不是所有的浏览器都支持.dataset属性，测试的浏览器中只有Chrome和Opera支持。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tu&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = article.dataset;</span><br><span class="line">alert(data.category); <span class="comment">// &quot;Web Development&quot;</span></span><br><span class="line">alert(data.author); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果把HTML5看作一个开放平台，那他的构建模块有哪些？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>, <span class="tag">&lt;<span class="name">header</span>&gt;</span>,<span class="tag">&lt;<span class="name">section</span>&gt;</span>, <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>H5的语义化作用及语义化标签</p>
<ol>
<li><p>什么是语义化</p>
<p>标签有了自己的含义，通过标签就能判断内容语义。</p>
</li>
<li><p>语义化的好处</p>
<p>1、html结构清晰，代码可读性较好，便于团队维护和开发</p>
<p>2、更有利于搜索引擎或辅助设备理解html页面内容，搜索引擎可以根据标签语言确定上下文和权重关系</p>
</li>
<li><p>常用的语义化标签</p>
<p>section, article, header, footer, nav, figure, dialog, progress, source, video, audio等等</p>
</li>
</ol>
</li>
<li><p>请解释script，script async 和script defer的区别</p>
<p>script：顺序解析执行</p>
<p>defer属性：脚本会被延迟到整个页面都解析完再运行，相当于告诉浏览器立即下载，但是延迟执行。会先于DOMContentLoaded事件执行，但是现实中延迟脚本不一定会按照顺序执行，也不一定再DOMContentLoaded之前执行，因此最好只包含一个延迟脚本。defer属性值针对外部脚本文件，同同时考虑到兼容性，把延迟脚本放在页面底部仍然是最佳选择。</p>
<p>async属性：这个属性同样只适用于外部脚本文件，但与 defer 不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 为此，建议异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之 后执行。</p>
<p>PS：async下载完立即执行，defer待界面文档解析完成之后执行</p>
</li>
<li><p>为什么通常推荐将 CSS <code>&lt;link&gt;</code> 放置在 <code>&lt;head&gt;&lt;/head&gt;</code> 之间，而将 JS <code>&lt;script&gt;</code> 放置在 <code>&lt;/body&gt;</code> 之前？你知道有哪些例外吗？</p>
<p>浏览器在处理HTML页面渲染和JavaScript脚本执行的时候是单一进程的,所以在当浏览器在渲染HTML遇到了<code>&lt;script&gt;</code>标签会先去执行标签内的代码(如果是使用src属性加载的外链文件,则先下载再执行),在这个过程中,页面渲染和交互都会被阻塞。所以将<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前,当页面渲染完成再去执行<code>&lt;script&gt;</code>。</p>
<p>一般希望DOM还没加载必须需要先加载的js会放置在<code>&lt;head&gt;</code>中,有些加了defer、async的<code>&lt;script&gt;</code>也会放在<code>&lt;head&gt;</code>中。</p>
</li>
<li><p>什么是渐进式渲染（progressive rendering）？</p>
<p>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</p>
<p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p>
<p>举例：</p>
<p>（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。</p>
<p>（2）确定显示内容的优先级（<code>分层次渲染</code>）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。</p>
<p>（3）异步加载HTML片段——当页面通过<strong>后台渲染</strong>时，把HTML拆分，通过异步请求，分块发送给浏览器。</p>
</li>
<li><p>HTML和XHTML有什么区别？</p>
<p>XHTML比HTML更加严格，只是按照XML的要求来规范HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. XHTML 元素必须被正确地嵌套。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. XHTML 元素必须被关闭。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.</span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3. 标签名必须用小写字母。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">P</span>&gt;</span>this is example.<span class="tag">&lt;<span class="name">P</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.1 空标签也必须被关闭</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">4.XHTML 文档必须拥有根元素。</span><br><span class="line">所有的 XHTML 元素必须被嵌套于 <span class="tag">&lt;<span class="name">html</span>&gt;</span> 根元素中。</span><br><span class="line"></span><br><span class="line">5. XHTML中标签的属性值要使用双引号”。</span><br></pre></td></tr></table></figure></li>
<li><p>HTML5新标签</p>
<p>导航链接<code>&lt;nav&gt;</code>，定义文章标签<code>&lt;article&gt;&lt;/article&gt;</code>, 标题<code>&lt;figure&gt;</code>(还可以和<code>&lt;dt&gt;&lt;dd&gt;</code>联合使用，其中<code>&lt;dt&gt;&lt;/dt&gt;</code>是写标题，而<code>&lt;dd&gt;</code>写内容), 对话框或窗口<code>&lt;dialog&gt;</code>, 菜单<code>&lt;menu&gt;</code>, 标题组<code>&lt;hgroup&gt;</code>, 定义小号文本<code>&lt;small&gt;</code>,</p>
<p>元素的细节<code>&lt;details&gt;</code>, 进度条的标签<code>&lt;progress&gt;</code>, 预定义范围内的度量<code>&lt;meter&gt;</code>, ruby 注释<code>&lt;ruby&gt;</code>.</p>
</li>
<li><p>HTML5新特性</p>
<p>一、语义标签</p>
<p>二、增强型表单</p>
<p>三、视频和音频</p>
<p>四、Canvas绘图</p>
<p>五、SVG绘图</p>
<p>六、地理定位</p>
<p>七、拖放API</p>
<p>八、WebWorker</p>
<p>九、WebStorage</p>
<p>十、WebSocket</p>
</li>
<li><p>SEO概念及实现</p>
<p><strong>SEO简介</strong></p>
<p>　　全称：Search Engine Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。</p>
<p>　　存在的意义：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望百度等搜索引擎能多多我们收录精心制作后的网站，并且在别人访问时网站能排在前面。</p>
<p>　　分类：白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？</p>
<p>　　1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</p>
<p>　　2. 网站内容优化：内容与关键字的对应，增加关键字的密度；</p>
<p>　　3. 在网站上合理设置Robot.txt文件；</p>
<p>　　4. 生成针对搜索引擎友好的网站地图；</p>
<p>　　5. 增加外部链接，到各个网站上宣传；</p>
<p><strong>SEO使用</strong></p>
<ol>
<li><p>网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</p>
<p> 　1. 控制首页链接数量<br>   　2. 扁平化的目录层次<br>   　3. 导航优化（图片导航添加alt，title等属性、面包屑导航）<br>   　4. 网站的结构布局<br>   　5. 控制页面的大小，减少http请求，提高网站的加载速度。</p>
</li>
<li><p>网页代码优化</p>
<p>1.<code>&lt;title&gt;</code>标题</p>
<p>2.<code>&lt;meta keywords&gt;</code>标签</p>
<p>3.<code>&lt;meta description&gt;</code>标签</p>
<p>4.<code>&lt;body&gt;</code>中的标签：尽量让代码语义化</p>
<p>5.<code>&lt;a&gt;</code>标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p>
<p>6.正文标题要用<code>&lt;h1&gt;</code>标签：“蜘蛛” 认为它最重要，若不喜欢<code>&lt;h1&gt;</code>的默认样式可以通过CSS设置。尽量做到正文标题用<code>&lt;h1&gt;</code>标签，副标题用<code>&lt;h2&gt;</code>标签, 而其它地方不应该随便乱用 h 标题标签。</p>
<p>7.<code>&lt;br&gt;</code>标签：只用于文本内容的换行</p>
<p>8.表格应该使用<code>&lt;caption&gt;</code>表格标题标签</p>
<p>9.<code>&lt;img&gt;</code>应使用 “alt” 属性加以说明</p>
<p>10.<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>标签 : 需要强调时使用。<code>&lt;strong&gt;</code>标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，<code>&lt;em&gt;</code>标签强调效果仅次于<code>&lt;strong&gt;</code>标签。<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>标签: 只是用于显示效果时使用，在SEO中不会起任何效果。</p>
<p>11.文本缩进不要使用特殊符号 &nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。</p>
<p>12.巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。</p>
<p>13.重要内容不要用JS输出，因为“蜘蛛”不认识</p>
<p>14.尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容</p>
<p>15.谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。</p>
<p>16.不断精简代码</p>
<p>17.js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。</p>
<ol start="18">
<li>table布局对SEO不友好</li>
</ol>
</li>
</ol>
</li>
<li><p>web worker和web socket</p>
<p>web socket提供更高效的传输协议，web worker提供多线程提高web应用计算效率。</p>
<p><strong>一.web socket</strong></p>
<p>1.web socket是一种协议，本质上和http，tcp一样。协议是用来说明数据是如何传输的</p>
<p>2.web socket的前缀有两种：（1）ws://  不是加密的。 (2)wss://  是加密的。</p>
<p>3.客户端和服务端进行web socket交互的方式也可以理解为“http握手 + tcp数据传输”的方式：</p>
<p>（1）浏览器（支持Websocket的浏览器）像HTTP一样，发起一个请求，然后等待服务端的响应；</p>
<p>（2）服务器返回握手响应，告诉浏览器请将后续的数据按照websocket制定的数据格式传过来；</p>
<p>（3）浏览器和服务器的socket连接不中断，此时这个连接和http不同的是它是双工的了；</p>
<p>（4）浏览器和服务器有任何需要传递的数据的时候使用这个长连接进行数据传递。</p>
<p>4.<strong>websocket的数据传输形式</strong>是：frame。比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处：</p>
<p>（1）大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。</p>
<p>（2）和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。</p>
<p>5.客户端使用web socket的语法：JavaScript。</p>
<p>  服务端：多种web框架</p>
<p><strong>二.web worker</strong></p>
<p>1.当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p>
<p>而web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p><strong>除了DOM操作之外</strong>，理论上任何JS脚本任务都可放入worker中执行；语法上的限制，则是<strong>不能跨域访问JS</strong>。worker常用于需要消耗大量时间和CPU资源的复杂计算，以换来前台用户操作的友好型；换句话说，从用户体验上看，<strong>提高了服务性能</strong>。</p>
<p>2.web worker使用：(当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。) 通过向 web worker 添加一个 “onmessage” 事件监听器来获取接受到的消息。发送消息：postMessage()。终止 web worker，并释放浏览器/计算机资源: terminate()。</p>
</li>
</ol>
<hr>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li><p>css画各种图形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">//等腰三角形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等腰梯形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扇形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//圆</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">border-radius: 25px;//50% 边框半径为宽高的50%</span><br><span class="line">&#125;</span><br><span class="line">半圆</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="comment">/* border-bottom-left-radius: 50px; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>css权重及其引入方式</p>
<p>css的引入可以通过行间样式，内部样式表（head中的style标签内），导入（@import）和外部样式表（<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/global.css&quot;&gt;</code>）引入。</p>
<p>而css权重主要是由数值决定的，权重会叠加，具体对应数值如下：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>！important（css语句后面加）</td>
<td>Infinity</td>
</tr>
<tr>
<td>行间样式</td>
<td>1000</td>
</tr>
<tr>
<td>id</td>
<td>100</td>
</tr>
<tr>
<td>class、属性、伪类</td>
<td>10</td>
</tr>
<tr>
<td>标签、伪元素</td>
<td>1</td>
</tr>
<tr>
<td>通配符、继承的样式</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>什么是文档流（normal flow）</p>
<p>流实际上就是浏览器在页面上摆放Html元素所用的方法，大多数元素默认在文档流中。浏览器从Html文件最上面开始，从上到下沿着元素流逐个显示所遇到的各个元素。即：元素按HTML中编写的先后顺序，上下左右堆叠排列。其中块级元素前后换行，内联元素前后不换行。</p>
<ol>
<li>窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；</li>
<li>每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；</li>
<li>内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；</li>
<li>有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。</li>
</ol>
</li>
<li><p>css定位属性</p>
<p>position：</p>
<ol>
<li>static：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。（默认值）</li>
<li>relative：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</li>
<li>absolute：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。（脱离normal flow）</li>
<li>fixed：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。</li>
<li>sticky：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table<code>时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同</li>
<li>inherit：规定应该从父元素继承 position 属性的值。</li>
</ol>
</li>
<li><p>flex布局</p>
<p>弹性布局：任何一个容器都可以成为flex布局，行内元素也是可以的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br></pre></td></tr></table></figure>
<p>具体的flex布局的容器和项目的属性在这篇博客上有很好的介绍：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
<li><p>px、em、rem的区别</p>
<p><strong>px像素（Pixel）</strong>。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p>
<p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>
<p><strong>EM特点</strong></p>
<ul>
<li> em的值并不是固定的；</li>
<li> em会继承父级元素的字体大小。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<p>所以我们在写CSS的时候，需要注意两点：</p>
<ul>
<li>\1. body选择器中声明Font-size=62.5%；</li>
<li>\2. 将你的原来的px数值除以10，然后换上em作为单位；</li>
<li>\3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</li>
</ul>
<p>也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</p>
</blockquote>
<p><strong>REM</strong></p>
<p>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>; <span class="attribute">font-size</span>:.<span class="number">875rem</span>;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p>
</blockquote>
<h3 id="px-与-rem-的选择？"><a href="#px-与-rem-的选择？" class="headerlink" title="px 与 rem 的选择？"></a>px 与 rem 的选择？</h3><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。</p>
<p>对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。</p>
</li>
<li><p>IFC与BFC</p>
<p>Box Formatting Context（块级格式化上下文）和Inline Formatting Context</p>
<p><strong>IFC布局规则</strong>：</p>
<blockquote>
<p>在行内格式化上下文中，框(boxes)一个接一个地水平排列，起点是包含块的顶部。水平方向上的 <code>margin</code>，<code>border</code> 和 <code>padding</code>在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</p>
</blockquote>
<p><strong>BFC布局规则</strong>：</p>
<blockquote>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由<code>margin</code>决定。属于同一个BFC的两个相邻Box的<code>margin</code>会发生重叠</li>
<li>每个元素的左外边缘（<code>margin-left</code>)， 与包含块的左边（<code>contain box left</code>）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li>
<li>BFC的区域不会与<code>float box</code>重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
</blockquote>
<p>块级格式化上下文由以下之一创建：</p>
<blockquote>
<ol>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 <code>float</code> 不是 <code>none</code>)</li>
<li>绝对定位的元素 (元素具有 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>非块级元素具有 <code>display: inline-block，table-cell, table-caption, flex, inline-flex</code></li>
<li>块级元素具有<code>overflow</code> ，且值不是 <code>visible</code></li>
</ol>
</blockquote>
<p>BFC的用处为清除浮动，自适应双栏布局，以及消除margin合并之类的能力。（最常见的就是为块级元素添加overflow：hidden）最常见的就是<code>overflow:hidden</code>、<code>float:left/right</code>、<code>position:absolute</code>。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</p>
</li>
<li><p>盒子模型以及理解</p>
<p>css布局是基于盒子模型的。都有如下三个属性</p>
<ul>
<li><code>padding</code>：即内边距，围绕着内容（比如段落）的空间。</li>
<li><code>border</code>：即边框，紧接着内边距的线。</li>
<li><code>margin</code>：即外边距，围绕元素外部的空间。</li>
</ul>
<p>W3C标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p>
</li>
<li><p>Less预处理语言</p>
<p>less是css的扩充，可以通过script或者npm引入，提供了变量（@name），函数，混合模式之类的特性。</p>
</li>
<li><p>三列布局</p>
<p>在这里只讨论两列定宽一列自适应的场景。</p>
<p>可以通过float + margin; float + overflow; table; flex; grid五种方式去实现，这里展示一下flex；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#parent</span> &#123;</span></span><br><span class="line">    height: 500px;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#left</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;  <span class="comment">/*间距*/</span></span></span><br><span class="line">    width: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#center</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;  <span class="comment">/*间距*/</span></span></span><br><span class="line">    width: 200px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#eeff2b</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#right</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">flex</span>: 1;  <span class="comment">/*均分#parent剩余的部分达到自适应*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#0f0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>圣杯布局和双飞翼布局的实现</p>
<p>这两个问题其实是三列布局中的固定两边中间自适应的问题</p>
<p>首先是圣杯布局，使用flex是最简单的方式，当然还可以通过float，绝对定位，grid之类的方法，这里看一下flex的方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.header</span>,<span class="selector-class">.footer</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span>&#123;</span></span><br><span class="line">        flex: 1;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:pink</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        background: aqua;</span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这里是头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>中间部分<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>这里是底部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是双飞翼布局，通过float布局完成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background: red;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 500px;</span><br><span class="line">        background: yellow;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">        margin: 0 200px; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background: blue;</span><br><span class="line">        margin-left: -200px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="12">
<li><p>margin塌陷及合并问题</p>
<p>所谓的margin塌陷是指父子嵌套元素在垂直方向的margin，父子元素是结合在一起的，margin会取最大值。</p>
<p>可以通过设置padding，border或者触发BFC来解决。</p>
<p>而margin合并是指兄弟结构的两个元素在垂直方向上的margin是会合并的。解决方式也是通过BFC，但是在实际开发中，最好不要采用这种改变DOM结构的方式，而是通过只设置一个margin来调节。</p>
</li>
<li><p>vh与vw</p>
<p><strong>视口单位(Viewport units)</strong></p>
<p>什么是视口？ </p>
<p>在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p>
<p>视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport, <strong>“视区”所指为浏览器内部的可视区域大小</strong>，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>
<p>根据CSS3规范，视口单位主要包括以下4个：</p>
<p>   1.vw：1vw等于视口宽度的1%。</p>
<p>   2.vh：1vh等于视口高度的1%。</p>
<p>   3.vmin：选取vw和vh中最小的那个。（一百等分）</p>
<p>   4.vmax：选取vw和vh中最大的那个。（一百等分）</p>
</li>
<li><p>如何实现响应式布局</p>
<p>Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。</p>
<h4 id="（一）em、rem"><a href="#（一）em、rem" class="headerlink" title="（一）em、rem"></a>（一）em、rem</h4><h3 id="通过rem来实现响应式布局"><a href="#通过rem来实现响应式布局" class="headerlink" title="通过rem来实现响应式布局"></a>通过rem来实现响应式布局</h3><p>rem单位都是相对于根元素html的font-size来决定大小的，根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。</p>
<p>因此，如果通过rem来实现响应式的布局，只需要<strong>根据视图容器的大小，动态的改变font-size即可</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function refreshRem() &#123;</span><br><span class="line">    var docEl &#x3D; doc.documentElement;</span><br><span class="line">    var width &#x3D; docEl.getBoundingClientRect().width;</span><br><span class="line">    var rem &#x3D; width &#x2F; 10;</span><br><span class="line">    docEl.style.fontSize &#x3D; rem + &#39;px&#39;;</span><br><span class="line">    flexible.rem &#x3D; win.rem &#x3D; rem;</span><br><span class="line">&#125;</span><br><span class="line">win.addEventListener(&#39;resize&#39;, refreshRem);</span><br></pre></td></tr></table></figure>
<h4 id="（二）flex弹性盒模型"><a href="#（二）flex弹性盒模型" class="headerlink" title="（二）flex弹性盒模型"></a>（二）flex弹性盒模型</h4><h4 id="（三）媒体查询"><a href="#（三）媒体查询" class="headerlink" title="（三）媒体查询"></a>（三）媒体查询</h4><p>使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。</p>
<p>设置步骤如下：</p>
<h5 id="1-设置-Meta-标签"><a href="#1-设置-Meta-标签" class="headerlink" title="1. 设置 Meta 标签"></a>1. 设置 Meta 标签</h5><p>大多数移动浏览器将<a href="http://caibaojian.com/t/html">HTML</a>页面放大为宽的视图（viewport）以符合屏幕分辨率。你可以使用视图的meta标签来进行重置。下面的视图标签告诉浏览器，使用设备的宽度作为视图宽度并禁止初始的缩放。在<code>&lt;head&gt;</code>标签里加入这个meta标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>（user-scalable = no 属性能够解决 iPad 切换横屏之后触摸才能回到具体尺寸的问题。 ）<a href="http://caibaojian.com/356.html">·</a></p>
<h5 id="2-通过媒介查询来设置样式-Media-Queries"><a href="#2-通过媒介查询来设置样式-Media-Queries" class="headerlink" title="2. 通过媒介查询来设置样式 Media Queries"></a>2. 通过媒介查询来设置样式 Media Queries</h5><p>Media Queries 是响应式设计的核心。</p>
<p>它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于 980px，那么可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width: 980px) &#123;</span><br><span class="line">  #head &#123; … &#125;</span><br><span class="line">  #content &#123; … &#125;</span><br><span class="line">  #footer &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的样式就会覆盖上面已经定义好的样式。</p>
<h5 id="3-设置多种试图宽度"><a href="#3-设置多种试图宽度" class="headerlink" title="3. 设置多种试图宽度"></a>3. 设置多种试图宽度</h5><p>如果需要设定兼容 iPad 和 iphone 的视图，那么可以这样设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** iPad **&#x2F;</span><br><span class="line">@media only screen and (min-width: 768px) and (max-width: 1024px) &#123;&#125;</span><br><span class="line">&#x2F;** iPhone **&#x2F;</span><br><span class="line">@media only screen and (min-width: 320px) and (max-width: 767px) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（四）使用百分比布局"><a href="#（四）使用百分比布局" class="headerlink" title="（四）使用百分比布局"></a>（四）使用百分比布局</h4><h4 id="（五）通过vw-vh来实现自适应"><a href="#（五）通过vw-vh来实现自适应" class="headerlink" title="（五）通过vw/vh来实现自适应"></a>（五）通过vw/vh来实现自适应</h4></li>
<li><p>z-index和叠加上下文是如何形成的</p>
<p>z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。</p>
<p>层叠上下文的概念：<br>层叠上下文就是html中的一个三维概念。相当于在水平面创建了一个z轴，有了层叠上下文的元素会离用户更近。它包含了一组层叠层的元素。我们所创建的每一个网页都有一个默认的层叠上下文，层叠上下文的根就是html，其他的所有元素都会在这个层叠上下文占据一个层叠水平，或高或低。</p>
<p>层叠顺序：<br>层叠顺序：这是一种规则，表示元素发生重叠时，在z轴上的显示顺序。<br>在一个层叠上下文中，有七种层叠顺序:</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/2149627777-5ad6b873234bb_articlex.png"></p>
<p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<ol>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ol>
</li>
<li><p>display以及相关属性</p>
<p>display 属性规定元素应该生成的框的类型。</p>
<table>
<thead>
<tr>
<th>none</th>
<th>此元素不会被显示。</th>
</tr>
</thead>
<tbody><tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
<tr>
<td>flex</td>
<td>弹性布局等等</td>
</tr>
</tbody></table>
</li>
<li><p>如何实现一个高性能css动画效果</p>
<p><strong>尽可能多的利用硬件能力，如使用3D变形来开启GPU加速</strong></p>
<p><strong>尽可能少的使用box-shadows与gradients</strong></p>
<p><strong>尽可能的让动画元素不在文档流中，以减少重排</strong></p>
<p><strong>优化 DOM layout 性能</strong></p>
</li>
<li><p>css3动画</p>
<p>@keyframes 规则是创建动画。</p>
<p>@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。</p>
<p>当在 <strong>@keyframes</strong> 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。</p>
<p>指定至少这两个CSS3的动画属性绑定向一个选择器：</p>
<ul>
<li>规定动画的名称</li>
<li>规定动画的时长</li>
</ul>
<p>用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p>
<p>0% 是动画的开始，100% 是动画的完成。</p>
</li>
<li><p>垂直水平居中</p>
<p>垂直和水平居中都可以通过align属性，table-cell，flex，以及绝对定位来实现</p>
<p>这里展现一下flex以及绝对定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">绝对定位：</span><br><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="comment">/*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>); </span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">flex</span>：</span><br><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距了，缺点就是需要知道宽高，使用transform倒是可以不需要，但是兼容性不好（ie9+）；</p>
<p>其次就是绝对居中，绝对定位设置top、left、right、bottom为0，然后<code>margin:auto;</code> 让浏览器自动平分边距以达到水平垂直居中的目的；</p>
<p>如果是行内/行内块级/图片这些内容，可以优先考虑<code>line-height</code>和<code>vertical-align</code> 结合使用，不要忘了还有<code>text-align</code> ，这个方法代码其实不多，就是理解原理有点困难，想要熟练应对各种情况还需好好研究；</p>
<p>移动端兼容性允许的情况下能用flex就用flex。</p>
</li>
<li><p>box-sizing</p>
<p>语法：box-sizing:content-box|border-box|inherit;</p>
<p>设置box-sizing:border-box以后，如果想要一个宽度为200px的盒子，那么我们直接设置宽度为200px。当再设置它的左右边框和左右补白后，它的内容区会自动调整（向里缩进）。</p>
</li>
<li><p>Sass</p>
<p>Sass 是一个 CSS 预处理器。</p>
<p>Sass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。</p>
<p>Sass 完全兼容所有版本的 CSS。</p>
<p>Sass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。</p>
<p>Sass 生成良好格式化的 CSS 代码，易于组织和维护。</p>
<p>Sass 文件后缀为 <strong>.scss</strong>。</p>
<p>Sass可以@import等等。</p>
</li>
<li><p>transform</p>
<p>Transform字面上就是变形，改变的意思。在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2021/01/19/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>Promise（A+规范）、then、all方法</p>
</li>
<li><p>Iterator遍历器实现</p>
</li>
<li><p>Thunk函数实现（结合Generator实现异步）</p>
</li>
<li><p>async实现原理（spawn函数）</p>
</li>
<li><p>class的继承</p>
</li>
<li><p>防抖和节流</p>
<a id="more"></a>
</li>
<li><p>Ajax原生实现</p>
</li>
<li><p>深拷贝的几种方法与比较</p>
</li>
<li><p>继承的几种实现与比较</p>
</li>
<li><p>未知宽高的元素水平垂直居中</p>
</li>
<li><p>三栏布局的实现</p>
</li>
<li><p>两栏布局的实现</p>
</li>
<li><p>Vue高阶组件</p>
</li>
<li><p>数组去重</p>
</li>
<li><p>几种排序算法的实现及其复杂度比较</p>
</li>
<li><p>前序后序遍历二叉树（递归与非递归）</p>
</li>
<li><p>重建二叉树（不含重复数字）</p>
<p>主要流程：新建根节点，查找根节点在中序中对应的索引，构建左右子树，递归解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        list[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> recur = <span class="function"><span class="keyword">function</span>(<span class="params">root, left, right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//指定null以符合treenode格式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line">        <span class="keyword">let</span> i = list[preorder[root]];</span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">        node.right = recur(i - left + root + <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="18">
<li><p>二叉树深度遍历（分析时间复杂度）</p>
</li>
<li><p>跨域的实现（JSONP、CORS）</p>
</li>
<li><p>矩阵搜索（不固定起始位置）</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</li>
</ol>
<pre><code>dfs + 剪枝算法

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || board[i][j] != word[k])&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>))&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="21">
<li><p>矩阵搜索（固定起始位置）：</p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
</ol>
<pre><code>dfs + 剪枝 + 回溯

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        visited[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, si, sj</span>)</span>&#123;</span><br><span class="line">        set = (i, j);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j] == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, ((i + <span class="number">1</span>) % <span class="number">10</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>), sj) + dfs(i, j + <span class="number">1</span>, si, ((j + <span class="number">1</span>) % <span class="number">10</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="22">
<li><p>剪绳子1</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>两个推论即均等长度剪并且x = 3有最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> n - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** a&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** (a - <span class="number">1</span>) * <span class="number">4</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> ** a * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>剪绳子2</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>需要取模，整体的数值kuoda，可能超过上限，因此采用循环取余法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> reminder = <span class="function">(<span class="params">x, a, p</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rem = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a; i++)&#123;</span><br><span class="line">            rem = rem * x % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rem;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> (n - <span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a, p);&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a - <span class="number">1</span>, p) * <span class="number">4</span> % p;&#125;</span><br><span class="line">    <span class="keyword">return</span> reminder(<span class="number">3</span>, a, p) * <span class="number">2</span> % p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>二进制数中的1的个数</p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(count)&#123;</span><br><span class="line">        res += n&amp;<span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要注意的是，如果不是无符号整数，是负数，则需要先取补码-&gt;移动-&gt;低位剪1-&gt;取反</p>
</li>
<li><p>快速幂</p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//二分法快速幂完成</span></span><br><span class="line">    <span class="keyword">if</span>(x === <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">        x = x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>打印从1到最大的n位数（考虑大数问题）</p>
<p>首先看一下原题中的要求，不需要大数：因此随便写写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> ** n; i++)&#123;</span><br><span class="line">        res.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是当要考虑大数的时候就需要通过String类型来实现，结合dfs：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">k</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push(num.slice(i, n).join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[k] = i;</span><br><span class="line">            dfs(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> num = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        num.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>简单的删除链表节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next.val == val)&#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>正则匹配</p>
<p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
</li>
</ol>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isMatch = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;<span class="comment">//动态规划，慢慢理解，注意边界值。</span></span><br><span class="line">    <span class="keyword">const</span> m = s.length;</span><br><span class="line">    <span class="keyword">const</span> n = p.length;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">matches</span>(<span class="params">i, j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt;= m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(matches(i, j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(matches(i, j))&#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="29">
<li><p>表示数值的字符串</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<p>//有限状态机，奇技淫巧，用python写写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            &#123; <span class="string">&#x27; &#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">4</span> &#125;, <span class="comment"># 0. start with &#x27;blank&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">4</span> &#125; ,                <span class="comment"># 1. &#x27;sign&#x27; before &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;, <span class="comment"># 2. &#x27;digit&#x27; before &#x27;dot&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;,         <span class="comment"># 3. &#x27;digit&#x27; after &#x27;dot&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span> &#125;,                         <span class="comment"># 4. &#x27;digit&#x27; after &#x27;dot&#x27; (‘blank’ before &#x27;dot&#x27;)</span></span><br><span class="line">            &#123; <span class="string">&#x27;s&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span> &#125;,                 <span class="comment"># 5. &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span> &#125;,                         <span class="comment"># 6. &#x27;sign&#x27; after &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;,                 <span class="comment"># 7. &#x27;digit&#x27; after &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;                          <span class="comment"># 8. end with &#x27;blank&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>: t = <span class="string">&#x27;d&#x27;</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>: t = <span class="string">&#x27;s&#x27;</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;eE&quot;</span>: t = <span class="string">&#x27;e&#x27;</span>     <span class="comment"># e or E</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;. &quot;</span>: t = c       <span class="comment"># dot, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">&#x27;?&#x27;</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>调整数组顺序使奇数位于偶数前面</p>
<p>简单双指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;left++;&#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;right--;&#125;</span><br><span class="line">        tmp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>链表中倒数第k个节点</p>
<p>依旧是双指针~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = head, q = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &lt; k ? <span class="literal">null</span> : q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>经典题目——反转链表</p>
<p>首先是双指针法，这个方法效率比较低(O N;O 1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = fast.next;</span><br><span class="line">        fast.next = slow;</span><br><span class="line">        slow = fast;</span><br><span class="line">        fast = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后是递归法，先递归到链表的末端，然后在返回的过程中，改变节点的指向（O N; O N)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个有序链表</p>
<p>双指针遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = l1 ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>判断树的子结构</p>
<p>通过两个递归，先序遍历并且判断包不包含子结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a || a.val != b.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(a.left, b.left) &amp;&amp; recur(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>输出二叉树镜像</p>
<p>可以通过递归也可以通过辅助栈解决，这里只展示一下递归法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(node);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>判断二叉树的对称性</p>
<p>递归解决问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">A, B</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; !B)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!A || !B || A.val != B.val)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.right) &amp;&amp; recur(A.right, B.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root ? recur(root.left, root.right) : <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>包含min函数的栈</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>通过辅助栈可以快速解决，期间发现一个问题就是空数组不可以和[ ]比较，因为右端的[ ]会自动转换为true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = [];</span><br><span class="line">    <span class="built_in">this</span>.minimum = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.minimum.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.push(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>] &gt;= x)&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>] == <span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>模拟栈的压入、弹出序列</p>
<p>使用辅助栈，简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">pushed</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">popped</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> pushed.values())&#123;</span><br><span class="line">        stack.push(i);</span><br><span class="line">        <span class="keyword">while</span>(stack.length != <span class="number">0</span> &amp;&amp; stack[stack.length - <span class="number">1</span>] == popped[num])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>从上到下打印二叉树</p>
<ol>
<li><p>第一种是从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。通过辅助队列，BFS解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">while</span>(queue.length != <span class="number">0</span>)&#123;</span><br><span class="line">        node = queue.shift();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;queue.push(node.left);&#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;queue.push(node.right);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种是从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。修改一下打印的循环就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">let</span> len;</span><br><span class="line">    <span class="keyword">while</span>(queue.length != <span class="number">0</span>)&#123;</span><br><span class="line">        len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        <span class="keyword">for</span>(;len &gt; <span class="number">0</span>;)&#123;</span><br><span class="line">            node = queue.shift();</span><br><span class="line">            tmp.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;queue.push(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;queue.push(node.right);&#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种为请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。在上一种的基础上，加一个标志位判断奇数偶数就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">let</span> node;</span><br><span class="line">    <span class="keyword">let</span> len;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.length != <span class="number">0</span>)&#123;</span><br><span class="line">        len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        <span class="keyword">for</span>(;len &gt; <span class="number">0</span>;)&#123;</span><br><span class="line">            node = queue.shift();</span><br><span class="line">            <span class="keyword">if</span>(flag &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                tmp.push(node.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.unshift(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;queue.push(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;queue.push(node.right);&#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(tmp);</span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>二叉搜索树的后序遍历序列</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>通过递归实现，经历循环的划分左右子树和判断左右子树的过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> verifyPostorder = <span class="function"><span class="keyword">function</span>(<span class="params">postorder</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> p = left</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[right])&#123;p++;&#125;</span><br><span class="line">        <span class="keyword">let</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[right])&#123;p++;&#125;</span><br><span class="line">        <span class="keyword">return</span> p == right &amp;&amp; recur(left, m - <span class="number">1</span>) &amp;&amp; recur(m, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(<span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树中和为某一值的路径</p>
<p>通过递归实现，注意添加path不能直接添加对象，而是添加一个拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> path = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">root, target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; !root.left &amp;&amp; !root.right)&#123;</span><br><span class="line">            res.push(path.slice());</span><br><span class="line">        &#125;</span><br><span class="line">        recur(root.left, target);</span><br><span class="line">        recur(root.right, target);</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    recur(root, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂链表的赋值</p>
<p>解决方法是通过拆分，首先合并链表然后修改random最后拆分出来，注意原链表的一致性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">        tmp.next = cur.next;</span><br><span class="line">        cur.next = tmp;</span><br><span class="line">        cur = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random)&#123;</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre = head;</span><br><span class="line">    <span class="keyword">let</span> res = cur = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉搜索树与双向链表</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>dfs后序遍历满足递增的要求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,left,right) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.left = left;</span></span><br><span class="line"><span class="comment"> *    this.right = right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> treeToDoublyList = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            root.left = pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = pre;</span><br><span class="line">    pre.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串的排列</p>
<p>通过回溯法，固定字符，并且通过set去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [s];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> list = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  permutationCore(list, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">permutationCore</span>(<span class="params">list, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin === list.length) &#123;</span><br><span class="line">      res.push(list.join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(list[i])) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(list[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> temp = list[begin];</span><br><span class="line">        list[begin] = list[i];</span><br><span class="line">        list[i] = temp;</span><br><span class="line"></span><br><span class="line">        permutationCore(list, begin + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        temp = list[begin];</span><br><span class="line">        list[begin] = list[i];</span><br><span class="line">        list[i] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>序列化与反序列化二叉树</p>
<p>BFS是核心思想，通过辅助队列，一层一层解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + res.join(<span class="string">&quot;,&quot;</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="string">&quot;[]&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> nodes = data.substring(<span class="number">1</span>, data.length - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(nodes[<span class="number">0</span>]));</span><br><span class="line">    queue.push(node);</span><br><span class="line">    <span class="keyword">while</span>(queue.length != <span class="number">0</span>)&#123;</span><br><span class="line">        root = queue.shift();</span><br><span class="line">        <span class="keyword">if</span>(nodes[i] != <span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">            root.left = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(nodes[i]));</span><br><span class="line">            queue.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(nodes[i] != <span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">            root.right = <span class="keyword">new</span> TreeNode(<span class="built_in">parseInt</span>(nodes[i]));</span><br><span class="line">            queue.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your functions will be called as such:</span></span><br><span class="line"><span class="comment"> * deserialize(serialize(root));</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组中出现次数超过一半的数字</p>
<p>除了常见的遍历统计之类的方式还有一种更加快捷的方式，通过摩尔投票法，遍历数组，votes == 0,剔除之前的，重新设置众数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> major = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> votes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(votes == <span class="number">0</span>)&#123;</span><br><span class="line">            major = num;</span><br><span class="line">        &#125;</span><br><span class="line">        votes += (major == num) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> major;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>最小的k个数</p>
<p>也就是熟悉的TopK问题，除了最大最小堆（当然js中没有对应数据结构），最优解是快排，平均可以达到O（N）的性能，但是这里因为不要求顺序，因此使用的是快排的改进版，也就是quickSelect。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == [])&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    topK(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>, k);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> topK = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right, k</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = quickSelect(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span>(k == m)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; m)&#123;topK(arr, left, m - <span class="number">1</span>, k);&#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; m)&#123;topK(arr, m + <span class="number">1</span>, right, k);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> quickSelect = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = arr[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= flag)&#123;right--;&#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= flag)&#123;left++;&#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = flag;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>数据流中的中位数</p>
<p>除了下面的解法，也就是在插入的时候就保证是顺序的，还可以通过双堆解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MedianFinder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.nums = [];</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MedianFinder.prototype.addNum = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums.push(num);</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.nums[i] &gt; num)&#123;</span><br><span class="line">            <span class="built_in">this</span>.nums.splice(i, <span class="number">0</span>, num);</span><br><span class="line">            <span class="built_in">this</span>.flag = (<span class="built_in">this</span>.flag == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.nums.push(num);</span><br><span class="line">    <span class="built_in">this</span>.flag = (<span class="built_in">this</span>.flag == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MedianFinder.prototype.findMedian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.nums == [])&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="comment">// console.log(this.nums);</span></span><br><span class="line">    <span class="comment">// console.log(this.flag);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.flag == <span class="number">1</span> ? <span class="built_in">this</span>.nums[<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.nums.length / <span class="number">2</span>)] : ((<span class="built_in">this</span>.nums[<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.nums.length / <span class="number">2</span>) - <span class="number">1</span>] + <span class="built_in">this</span>.nums[<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.nums.length / <span class="number">2</span>)]) / <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>连续子数组的最大和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划秒解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        nums[i] += <span class="built_in">Math</span>.max(nums[i -<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>1~n整数中1出现的次数</p>
<p>找规律？找规律！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countDigitOne = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这种题就要找规律，与之前做的那道找某个位置是什么数字的类似</span></span><br><span class="line">    <span class="comment">// 现在有一个函数f(n)，代表n位上有多少个1</span></span><br><span class="line">    <span class="comment">//         f(0) = 0</span></span><br><span class="line">    <span class="comment">//  0~9    f(1) = 1</span></span><br><span class="line">    <span class="comment">//  0~99   f(2) = 10 + 10*f(1) = 20  (10+为  10~19中十位有10个1)</span></span><br><span class="line">    <span class="comment">//  0~999  f(3) = 100 + 10*f(2) = 300  (100+为  100~199中百位有100个1)</span></span><br><span class="line">    <span class="comment">//  10~9999 f(4) = 1000 + 10*f(3) = 4000 (...)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如 5467 中有多少个1</span></span><br><span class="line">    <span class="comment">// 1. 0~5000中有 5 * f(3) + 1000 = 2500个</span></span><br><span class="line">    <span class="comment">// 2. 0~400中有 4 * f(2) + 100 = 180个</span></span><br><span class="line">    <span class="comment">// 3. 0~60中有 6 * f(1) + 10 = 16个</span></span><br><span class="line">    <span class="comment">// 4. 0~7中有 7 * f(0) + 1 = 1个</span></span><br><span class="line">    <span class="comment">// 所以5467中有2697个1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">300</span>,<span class="number">4000</span>,<span class="number">50000</span>,<span class="number">600000</span>,<span class="number">7000000</span>,<span class="number">80000000</span>,<span class="number">900000000</span>,<span class="number">10000000000</span>];</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> str = n + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> len = str.length;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">Math</span>.pow(<span class="number">10</span>,len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> p = len - <span class="number">1</span>; <span class="comment">//解析中的n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res += str[i] * f[p];</span><br><span class="line">        <span class="keyword">if</span>(str[i] === <span class="string">&#x27;1&#x27;</span> &amp;&amp; i !== len - <span class="number">1</span>) &#123;<span class="comment">//中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上</span></span><br><span class="line">        	res += <span class="built_in">Number</span>(str.slice(i + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[i] === <span class="string">&#x27;1&#x27;</span> &amp;&amp; i === len - <span class="number">1</span>) &#123;<span class="comment">//解决末尾为1但未加上的bug</span></span><br><span class="line">        	res += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt; <span class="number">1</span>) res += m;</span><br><span class="line">        m /= <span class="number">10</span>, p -=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>手撕代码</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面经汇总</title>
    <url>/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>事件代理</p>
<p>事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能</p>
<p>具体原因看Q21事件冒泡机制</p>
</li>
<li><p>请解释Javascript中的this是如何工作的（如何正确判断）</p>
<p>this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。</p>
<p>在call和apply中this指向指定的对象，如果指定的参数是null或undefined，则指向window。</p>
<p>在箭头函数中，箭头函数是没有this的，因此this指向外层代码的对象。</p>
<a id="more"></a>
</li>
<li><p>原始值和引用值类型以及区别</p>
<p>JS的原始数据类型有boolean，null，undefined，bigint，number，string，symbol</p>
<p>引用数据类型：对象Object（普通，数组，正则，日期，数学，函数）</p>
<p>区别：</p>
<p>（1）值类型：</p>
<p>​            1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）</p>
<p>​            2、保存与复制的是值本身</p>
<p>​            3、使用typeof检测数据的类型</p>
<p>​            4、基本类型数据是值类型</p>
<p>（2）引用类型：</p>
<p>​            1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</p>
<p>​            2、保存与复制的是指向对象的一个指针</p>
<p>​            3、使用instanceof检测数据类型</p>
<p>​            4、使用new()方法构造出的对象是引用型</p>
</li>
<li><p>闭包与作用域</p>
<p>闭包是指那些能够访问自由变量的函数。（闭包 = 函数 + 函数能够访问的自由变量）/闭包是指有权访问另外一个函数作用域中的变量的函数</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li><p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>
</li>
<li><p>在代码中引用了自由变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();<span class="comment">//0</span></span><br><span class="line">data[<span class="number">1</span>]();<span class="comment">//1</span></span><br><span class="line">data[<span class="number">2</span>]();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>作用域：JS使用词法（静态）作用域，即函数的作用域在函数定义的时候就被确定了</p>
</li>
</ol>
<p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
</li>
<li><p>js继承</p>
<p>js中的继承需要靠原型来实现。</p>
<p>但是继承有一个问题是父类的所有属性，子类都会继承，因此使用组合代替继承是非常必要的。</p>
<p>五种方式实现继承：</p>
<p>​    call（子类中调用parent.call(this)，只能继承属性，但是不能继承方法）</p>
<p>​    借助原型链（child.prototype = new parent()，能继承方法，但是多个子类继承自同一个原型对象，属性值同时改变)</p>
<p>​    前两种组合，但是会导致父类构造函数执行多次</p>
<p>​    将父类原型给到子类的原型（但是子类的构造函数变成了父类）</p>
<p>​    寄生组合继承（最优）</p>
<p>​    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;parent5&#x27;</span>;</span><br><span class="line">   <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent5.call(<span class="built_in">this</span>);</span><br><span class="line">   <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line"> Child5.prototype.constructor = Child5;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>js模块化</p>
<p>AMD,CMD,ES6</p>
<p>AMD和CMD都是通过define()定义模块，AMD需要把依赖的模块先写出来，可以通过return暴露接口，CMD在定义模块需要传入require，exports和module这几个参数，要加载某个模块时，使用require进行加载，要暴露接口时，可以通过exports，module.exports和return。</p>
<p>而es6使用静态化加载而不是运行时加载，通过export和import按需加载（编译时加载）</p>
</li>
<li><p>new的原理</p>
<p>通过new创建对象经历五个步骤：创建一个新对象；设置这个空对象的实例原型；将构造函数的作用域赋给新对象；执行构造函数（赋属性）；返回新对象。</p>
</li>
<li><p>null undefined 区别</p>
<p>null表示”没有对象”，即该处不应该有值。</p>
<p>​    （1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>​    （2） 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>​    （1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>​    （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
</li>
<li><p>IIFE立即执行函数</p>
<p>立即执行函数即立即执行声明的函数（可以是匿名函数），有两种写法</p>
<p>列表1:IIFE写法一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>列表2:IIFE写法二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<ul>
<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。</li>
<li>IIFE中定义的任何变量和函数，都会在执行结束时被销毁，这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</li>
</ul>
</li>
<li><p>原型和原型链</p>
<p>所谓的原型就是在用构造函数创建对象时就会关联另一个对象A.prototype，并且对象会从这里继承属性。（更多像一种委托，建立关联调用）</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/prototype5.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>简而言之构造函数和实例原型之间是原型和构造的关系，对象之间通过__proto__向上调用.</p>
</li>
<li><p>深拷贝与浅拷贝</p>
<p>浅拷贝只拷贝一层对象，但是深拷贝可以通过递归解决对象嵌套的问题</p>
<p>浅拷贝实现方式：</p>
<ol>
<li>手动实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Object.assign</li>
</ol>
<p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;sy&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">&#x27;sss&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>concat浅拷贝数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>slice浅拷贝</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>…展开运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>深拷贝实现方式

简易版本的是JSON.parse(JSON.stringify())，但是这个方法无法解决循环引用，无法拷贝一些set，map之类的特殊对象，无法拷贝函数。

因此手动实现一个深拷贝(如果属性是对象，则递归;有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.get(target))&#123;<span class="keyword">return</span> hash.get(target);&#125;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        hash.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = <span class="keyword">typeof</span> target[prop] === <span class="string">&#x27;object&#x27;</span> ? deepClone(target[prop]) : target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还有jquery有一个提供$.extend 可以使用Deep Copy；函数库lodash的_.cloneDeep方法。</code></pre>
<ol start="12">
<li><p>匿名函数</p>
<p>匿名函数可以赋值或者自执行（IIFE），使用匿名函数赋值的时候，要先声明再使用。IIFE除了上面的方法，还可以通过{[], +, -, !, ~, void}调用</p>
</li>
<li><p>判断数据类型的方式</p>
<ol>
<li>typeof返回基本数据类型（除了null），引用类型中除了function返回function，其余返回object；</li>
<li>toString（）是 Object 的原型方法返回class属性，表示为[Object, Xxx]，除了object其他通过call/apply调用。（window-&gt;global, document-&gt;HTMLDocument）</li>
<li>constructor指向构造函数引用</li>
<li>instanceof通过原型链来判断A是否为B的实例（instance of null报错：右边不是一个对象）</li>
</ol>
</li>
<li><p>宿主对象和原生对象</p>
<p>ECMA-262 把原生对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）</p>
<p>由此可以看出，简单来说，原生对象就是 ECMA-262 定义的类（引用类型）。其中有一个子集叫做内置对象Global和Math（所有函数都必须是某个对象的方法）</p>
<p>所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的 BOM 和 DOM 对象都是宿主对象。document，window， navigator等</p>
</li>
<li><p>请指出以下代码的区别：<code>function Person()&#123;&#125;</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>？</p>
<p>第一个是声明一个函数Person；第二个是把函数的返回值赋给person，如果没有返回值就是undefined；第三个是new一个Person的实例对象。</p>
</li>
<li><p>防抖和节流</p>
<p>简而言之：防抖（debounce）让短时间内的连续触发的事件，在一定的时间间隔中，事件处理函数只执行一次；</p>
<p>而节流（throttle）就是让函数执行一次之后，在一段时间内失效，然后再生效（可以执行）。</p>
</li>
<li><p><code>document.write()</code></p>
<p>用于向HTML输出流中添加传入的内容，浏览器会顺着html元素顺序依次解析他们，并且显示出来，但是如果在页面渲染完成之后调用（onload），会重写整个document，导致之前所有的内容被覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(exp1,exp2,exp3,....);</span><br></pre></td></tr></table></figure></li>
<li><p>Ajax工作原理</p>
<p>Ajax(Asynchronous Java and XML的缩写)是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/v2-320935b9afabe806ff20993ead6c1048_1440w.png"></p>
</li>
<li><p>跨域、同源策略及跨域实现方式和原理</p>
<ol>
<li><p>同源策略是一种规定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求不能发送</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>
<p>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p>
<p>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</p>
<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
</li>
<li><p>跨域的九种解决方案</p>
<ol>
<li>JSONP</li>
<li>CORS(CORS 需要浏览器和后端同时支持。)</li>
<li>postMessage(postMessage是HTML5 XMLHttpRequest Level 2中的API;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。)</li>
<li>websocket</li>
<li>Node中间代理(实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。)</li>
<li>nginx反向代理</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>document.domain + iframe(该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。)</li>
</ol>
</li>
<li><p>总结</p>
<ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>
</li>
</ol>
</li>
<li><p>js中的垃圾回收机制</p>
<p>js中的垃圾回收是自动进行的，是不可见的。js中的内存管理主要的概念是可达性，根访问不到的都是垃圾。垃圾回收器会监视左右的对象并且删除不可访问的对象。基本的垃圾回收算法为标记-清除，垃圾回收器获取根，标记它，然后逐层访问并且标记引用的对象，最后除了标记过的，其余的都删除。（可以是删除没有标记的，又有一种是删除有标记的）（以前还有一种引用计数，但是引用计数会有循环引用的问题）</p>
<p>一些优化:</p>
<ul>
<li><strong>分代回收</strong>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li>
<li><strong>增量回收</strong>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li>
<li><strong>空闲时间收集</strong>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li>
</ul>
</li>
<li><p>冒泡机制</p>
<p>冒泡机制是指事件从DOM树的底层一层层向上传递，如果要终止传递可以通过对每一个元素进行event.stopPropagation()，或者通过在父元素中去判断targetid，分别作出相应的处理。</p>
</li>
<li><p>变量声明提升</p>
<p>变量声明会从他们在代码中出现的位置被移动到当前作用域的最上方进行执行，这个过程叫做提升。</p>
<p>函数也存在提升。但是在函数表达式中，由于是赋值，所以不可以提升。</p>
<p>在提升中有函数优先原则，函数反复声明会覆盖。</p>
<p>当然在实际编程中，要尽量避免提升问题。</p>
</li>
<li><p>document load 和 document DOMContentLoaded</p>
<p>当浏览器解析完文档就会触发DOMContentLoaded事件，脚本，css都会阻塞解析。</p>
<p>而当所有资源全部加载完毕之后，才会触发load事件（在DOMContentLoaded事件之后）。</p>
<p>P.S.为什么要js脚本放在最后（<code>&lt;/body&gt;</code>之前)？</p>
<p>​    其实现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p>
</li>
<li><p>== 和 ===有什么不同</p>
<p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p>
<p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p>
<p>操作数1 == 操作数2， 操作数1 === 操作数2</p>
<p>比较过程：</p>
<p>　　双等号==： </p>
<p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p>
<p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p>
<p>　　　　1）如果一个是null，一个是undefined，那么相等</p>
<p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较(或者是boolean)</p>
<p>　　</p>
<p>　　三等号===:</p>
<p>　　（1）如果类型不同，就一定不相等</p>
<p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值                是否是NaN，只能使用isNaN( ) 来判断）</p>
<p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p>
<p>　　（4）如果两个值都是true，或是false，那么相等</p>
<p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p>
<p>　　（6）如果两个值都是null，或是undefined，那么相等</p>
</li>
<li><p>js中的arguments</p>
<p>也是一个对象，是一个特殊的对象，属性的名是根据传入参数的序列来的，又叫做类数组对象。（proto属性指向Object.prototype）</p>
<p>可以通过length判断传入长度，可以索引取值使用参数，可以通过callee属性获取方法完整代码（匿名函数递归）（es4开始禁止？）</p>
</li>
<li><p>请解释什么是单页应用 (<code>single page app</code>), 以及如何使其对搜索引擎友好 (<code>SEO-friendly</code>)</p>
<p>只有一个页面的web应用程序就是单页应用。</p>
<p>单页应用对SEO不太友好，但是可以通过Prerender预渲染优化技术解决一部分问题。</p>
</li>
<li><p>Promise</p>
<p>Promise的出现解决了回调地狱</p>
<p>什么是回调地狱？</p>
<ol>
<li>多层嵌套的问题。</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<p>Promise 利用了三大技术手段来解决<code>回调地狱</code>:</p>
<ul>
<li><strong>回调函数延迟绑定</strong>。</li>
<li><strong>返回值穿透</strong>。</li>
<li><strong>错误冒泡</strong>。</li>
</ul>
<p>本质上 Promise 是一个函数返回的对象，它代表了一个异步操作的最终完成或者失败。我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<p>Promise由于catch，then，finally返回的是一个新的Promise对象，因此实现了链式调用。</p>
<ul>
<li><p>Promise 中有三个状态 Pending（进行中）、Fulfilled（已成功）、Rejected（已失败）。外界无法改变这个三个状态，而且一旦状态改变就不会再变。</p>
</li>
<li><p>实例化一个 Promise 需要传入一个 <code>executor</code> 函数 ，业务代码在 <code>executor</code> 函数中执行，另外 <code>executor</code> 函数接收两个参数 <code>resolve</code> 和 <code>reject</code>。<code>resolve</code> 和 <code>reject</code> 是 Promise 构造函数的内置函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;... 业务代码</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>executor</code> 函数中业务代码执行成功了，调用 <code>resolve</code> 函数，把 Promise 的状态变为已成功，另外通过参数把业务代码的执行成功的结果传递到 Promise 中。</p>
</li>
<li><p>在 <code>executor</code> 函数中业务代码执行失败了，调用 <code>reject</code> 函数，把 Promise 的状态变为已失败，另外通过参数把业务代码的执行失败的原因传递到 Promise 中。</p>
</li>
<li><p>实例方法 <code>then</code> 的第一个参数是业务代码执行成功的回调函数，第二个参数是业务代码执行失败的回调函数，当业务代码执行完毕后，会根据执行结果调用对应的回调函数，且这些回调函数接收业务代码的执行结果作为参数。</p>
</li>
<li><p>通过实例方法 <code>catch</code> 来添加业务代码执行失败的回调函数。</p>
</li>
</ul>
</li>
<li><p>图片懒加载</p>
<p>图片懒加载实际上就是当页面滚动到当前图片的时候，就进行加载</p>
<p>首先有几个API：</p>
<pre><code>                    1. document.documentElement.clientHeight
                    2. element.offsetTop
                    3. document.documentElement.scrollTop</code></pre>
<p>而懒加载的加载条件就是offsetTop - scrollTop &lt; clientHeight</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        img &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">            margin-bottom: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/7.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/8.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/9.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/10.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//offsetTop是元素与offsetParent的距离，循环获取直到页面顶部</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getTop</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> T = e.offsetTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span>(e = e.offsetParent) &#123;</span></span><br><span class="line">                T += e.offsetTop;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> T;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params">imgs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> H = <span class="built_in">document</span>.documentElement.clientHeight;<span class="comment">//获取可视区域高度</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> S = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (H + S &gt; getTop(imgs[i])) &#123;</span></span><br><span class="line"><span class="javascript">                    imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//onscroll()在滚动条滚动的时候触发</span></span></span><br><span class="line">            lazyLoad(imgs);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更加便捷的一个方式就是通过getBoundingClientRect()，通过返回对象的属性bound.top &lt;= clientHeight（window.innerHeight?）进行判断是不是在视口内。</p>
</li>
<li><p>let var const</p>
<p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象，在全局中声明会变成window的属性；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，行为基本与let相同，但是在声明的时候必须要初始化变量，在后面出现的代码中不能再修改该常量的值。</p>
</li>
<li><p>什么是事件循环机制？</p>
<p>了解事件循环机制，首先就要去了解什么是同步异步。</p>
<p>js是单线程的，也就是说在JS引擎中负责解释和执行js代码的线程只有一个（主线程和工作线程之分）</p>
<p>同步是指返回的时候能得到预期的值，而异步是只返回时得不到预期的值。</p>
<p>一个异步过程通常是这样的：</p>
<blockquote>
<p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
</blockquote>
<p>异步函数通常具有以下的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A(args..., callbackFn)</span><br></pre></td></tr></table></figure>
<p>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数)<code>A</code></li>
<li>回调函数<code>callbackFn</code></li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。<br><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/3259161542-575018ce29d44_articlex.png"></p>
<p>那么什么是事件循环event loop呢？</p>
<p>事件循环是一种js的执行机制，分为宏任务和微任务。</p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p>
<p>对于宏任务和微任务来说（宏任务一轮循环结束后会在微任务队列中查找）：</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126200149.png"></p>
<p>对于Node.js来说有一些不同</p>
<p>nodejs 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<blockquote>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126202303.png"></p>
<p>梳理一下 nodejs 三个非常重要的执行阶段:</p>
<ol>
<li>执行 <code>定时器回调</code> 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它<code>timer</code>。</li>
<li>轮询(英文叫<code>poll</code>)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、</li>
</ol>
<p>‘connect’等事件使得事件循环到达 <code>poll</code> 阶段。到达了这个阶段后:</p>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li>如果队列<code>不为空</code>，拿出队列中的方法依次执行</li>
<li>如果队列为空，检查是否有 setImmdiate的回调<ul>
<li>有则前往<code>check阶段</code>(下面会说)</li>
<li><code>没有则继续等待</code>，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后<code>自动进入 check 阶段</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>check 阶段。这是一个比较简单的阶段，直接<code>执行 setImmdiate</code> 的回调。</li>
</ol>
<p>当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 <code>I/O异常的回调阶段</code>。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p>
<p>并且在 check 阶段结束后还会进入到 <code>关闭事件的回调阶段</code>。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， ‘close’ 事件的回调就会在这个阶段执行。</p>
</blockquote>
<p>node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。而 node 版本小于 11 的情况下，对于定时器的处理是: 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p>
<p><strong>nodejs 和 浏览器关于eventLoop的主要区别</strong></p>
<p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>中执行的，而nodejs中的微任务是在<code>不同阶段之间</code>执行的。node中process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<code>优先于微任务</code>执行。</p>
</li>
<li><p>函数柯里化</p>
<p>函数柯里化是一种函数的转换，将一个函数从可调用的f（a, b, c）变成可调用的f（a）（b）（c）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123; <span class="comment">// curry(f) 执行柯里化转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = _.curry(sum); <span class="comment">// 使用来自 lodash 库的 _.curry</span></span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3，仍可正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3，以偏函数的方式调用</span></span><br></pre></td></tr></table></figure>
<p>更加高级的原生实现，可以实现正常或者偏函数方式的调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt;= func.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pass</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<p>箭头函数表达式没有自己的this,arguments,super或new.target。</p>
<p>也就是说不绑定this，没有prototype属性，不能用作生成器，用call，apply调用，第一个参数会被忽略。</p>
<p>还有额外的一点就是箭头函数返回对象字面量的时候，要用括号包起来。</p>
</li>
<li><p>对象创建的三种方法</p>
<p>字面量方法：const obj = { }</p>
<p>new：const obj = new Object()</p>
<p>构造函数：通过function关键字加对象名称来创建</p>
</li>
<li><p>数组的方法</p>
<p>toString() 把数组转换为数组值（逗号分隔）的字符串。（如果需要原始值，则 JavaScript 会自动把数组转换为字符串。）</p>
<p>join() 方法也可将所有数组元素结合为一个字符串。</p>
<p>pop() 方法从数组中删除最后一个元素，返回“被弹出”的值。</p>
<p>push() 方法（在数组结尾处）向数组添加一个新的元素，返回新数组的长度。</p>
<p>shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回被“位移出”的字符串。</p>
<p>unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素，返回新数组的长度。</p>
<p>可以使用 JavaScript delete 运算符来<em>删除</em>，会在数组留下undefined。</p>
<p>splice() 方法可用于向数组添加新项，也可以用来删除元素，第二个参数定义了删除多少个元素，返回一个包含已删除项的数组。</p>
<p>concat() 方法通过合并（连接）现有数组来创建一个新数组，可以拼接任意个数组。</p>
<p>slice() 方法用数组的某个片段切出新数组。</p>
<p>还有sort()（可以自定义比值函数）和reverse()</p>
</li>
<li><p>addEventListener和onClick()的区别</p>
<p>一个是js事件绑定，另一个是普通事件。</p>
<p>普通事件就是直接触发事件，同一时间只能指向同一个对象，所以会被覆盖掉。</p>
<p>事件绑定就是对于一个可以绑定的事件对象，进行多次绑定事件都能运行。</p>
<p>addEventListener对任何DOM都是有效的，而onclick仅限于HTML</p>
<p>addEventListener可以控制listener的触发阶段,（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除。</p>
</li>
<li><p>setTimeout用作倒计时为何会产生误差？</p>
<p>如果当前 <strong>执行栈</strong> 所花费的时间大于 <strong>定时器</strong> 时间，那么定时器的回调在 <strong>宏任务(macrotask)</strong> 里，来不及去调用，所有这个时间会有误差。</p>
<p>我们看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;biubiu&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">某个执行时间很长的函数();</span><br></pre></td></tr></table></figure>
<p>如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 <strong>执行栈</strong> ，要等执行栈执行完毕后再去读取 <strong>微任务(microtask)**，等 **微任务(microtask)</strong> 完成，这个时候才会去读取 <strong>宏任务(macrotask)</strong> 里面的 <strong>setTimeout</strong> 回调函数执行。<strong>setInterval</strong> 同理，例如每3秒放入宏任务，也要等到执行栈的完成。</p>
<p>还有一种情况如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;嘤嘤嘤&#x27;</span>);</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在最新的规范里有这么一句： <strong>If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.</strong></p>
<p>所以意思就是意思就是如果timeout嵌套大于 5层，而时间间隔小于4ms，则时间间隔增加到4ms。</p>
</li>
<li><p>DOM的location对象</p>
<p>Location 对象实际上是 JavaScript 对象，而不是 HTML DOM 对象。</p>
<p>Location 对象是由 JavaScript runtime engine 自动创建的，包含有关当前 URL 的信息。</p>
<p>location指示了其所连接对象的url位置。Document和window对象中都有location属性，可以通过window.location和document.location访问。</p>
<p>location的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.location;</span><br><span class="line">url.href = <span class="string">&#x27;https://developer.mozilla.org/en-US/search?q=URL#search-results-close-container&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(url.href);      <span class="comment">// https://developer.mozilla.org/en-US/search?q=URL#search-results-close-container</span></span><br><span class="line"><span class="built_in">console</span>.log(url.protocol);  <span class="comment">// https:</span></span><br><span class="line"><span class="built_in">console</span>.log(url.host);      <span class="comment">// developer.mozilla.org</span></span><br><span class="line"><span class="built_in">console</span>.log(url.hostname);  <span class="comment">// developer.mozilla.org</span></span><br><span class="line"><span class="built_in">console</span>.log(url.port);      <span class="comment">// (blank - https assumes port 443)</span></span><br><span class="line"><span class="built_in">console</span>.log(url.pathname);  <span class="comment">// /en-US/search</span></span><br><span class="line"><span class="built_in">console</span>.log(url.search);    <span class="comment">// ?q=URL</span></span><br><span class="line"><span class="built_in">console</span>.log(url.hash);      <span class="comment">// #search-results-close-container</span></span><br><span class="line"><span class="built_in">console</span>.log(url.origin);    <span class="comment">// https://developer.mozilla.org</span></span><br></pre></td></tr></table></figure>
<p>方法为assign， reload， replace， toString，其中relace方法要求提供一个URL，使页面跳转到相应的URL，与location.assign()的区别是，location.replace()跳转后的页面不会保存在浏览器历史中，即无法通过返回按钮返回到该页面。</p>
</li>
<li><p>call，apply</p>
<p>每个函数都包含两个非继承而来的方法：call()和apply()；<br>在JavaScript中，call和apply作用是一样的，都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部this的指向。</p>
<p>区别：参数书写方式不同<br>call(thisObj, arg1, arg2, arg3, arg4);<br>apply(thisObj, [args]);<br>thisObj：call和apply第一个参数是一样的，该参数将替代Function类里面的this对象。<br>arg1,arg2….：是一个个的参数，<br>args：一个数组或类数组，是一个参数列表。</p>
<p><strong>用处就是可以改变函数作用域或者实现继承等</strong></p>
</li>
<li><p>实现页面加载进度条</p>
<ol>
<li><p>可以通过NProgress实现：<a href="https://ricostacruz.com/nprogress/">https://ricostacruz.com/nprogress/</a></p>
</li>
<li><p>youtube的进度条是通过：</p>
<p>Ajax：首先页面内容的加载使用的是Ajax异步请求，所以页头那个激光元素可以在内容请求与接收过程中得以展示，不然的话整个页面刷新那就无法实现了；<br>HTML5 History API: 其次我注意到页面地址也是跟着变的。前面提到整个页面是没有刷新的（，但页面地址却更新了，方便你把连接放送给别人时能够打开该页面。这里用到的就是HTML5的History API，通过它可以操作浏览器地址栏的地址，书签及页面状态信息等。<br>CSS3动画属性 ：另外就是红色激光线条本身的实现上，使用了CSS3的动画或者JS写的动画，但更大的可能是两种结合。</p>
</li>
</ol>
</li>
<li><p><code>strict</code>模式</p>
<p>所谓的strict模式就是要求强制声明变量，如果不声明就使用就会报出ReferenceError错误。</p>
<p>开启的方式就是在js代码的最顶上写上一个‘use strict’;</p>
</li>
<li><p>Symbol概念及其作用</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<p>symbol可以用来定义属性，消除魔术字符串等等。</p>
</li>
<li><p>Set和Map数据结构</p>
<p><strong>Set</strong></p>
<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>Set中NaN是等于自身的，以及两个对象总是不相等的。</p>
<p>有has，add，delete，clear方法，同时拥有四个方法可以进行成员的遍历</p>
<p><strong>WeakSet</strong></p>
<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>
<p>也有has，add，delete，clear方法，没有size，没有遍历的方法，需要注意的是，当接受数组或者类数组对象作为参数的时候，weakset会将每个数组成员变成自己的成员，也就是说数组中的必须要是对象。</p>
<p><strong>Map</strong></p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p><strong>WeakMap</strong></p>
<p>和WeakSet同理，有相同的限制（键只能是对象除了null），可以用来部署私有属性以及baocunDOM节点等等。</p>
</li>
<li><p>Proxy和Reflect对象</p>
<p><strong>Proxy</strong></p>
<p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li>
</ul>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。关键的是一定要返回和内建方法相同的返回值否则会报错。</p>
<p><strong>Reflect</strong></p>
<p><code>Reflect</code> 是一个内建对象，可简化 <code>Proxy</code> 的创建。</p>
<p>前面所讲过的内部方法，例如 <code>[[Get]]</code> 和 <code>[[Set]]</code> 等，都只是规范性的，不能直接调用。</p>
<p><code>Reflect</code> 对象使调用这些内部方法成为了可能。它的方法是内部方法的最小包装。</p>
<p>Proxy和Reflect可以组合使用，通过Reflect来将操作转发给原始对象，可以解决继承的问题。</p>
<p>Proxy也可以创建可撤销的代理（revokable），可以随时禁用。</p>
<p><strong>总结</strong></p>
<p>Reflect API 旨在补充 Proxy。对于任意 <code>Proxy</code> 捕捉器，都有一个带有相同参数的 <code>Reflect</code> 调用。我们应该使用它们将调用转发给目标对象。</p>
<p>Proxy 有一些局限性：</p>
<ul>
<li>内建对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上文中的解决方法。</li>
<li>私有类字段也是如此，因为它们也是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象作为 <code>this</code> 才能访问它们。</li>
<li>对象的严格相等性检查 <code>===</code> 无法被拦截。</li>
<li>性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍。实际上，这仅对某些“瓶颈”对象来说才重要。</li>
</ul>
</li>
<li><p>循环语法比较及使用场景（for、forEach、for…in、for…of）</p>
<p><strong>for循环</strong><br>缺点是很麻烦。<br><strong>forEach</strong><br>回调函数参数分别是value,index,array<br>缺点在于无法中途跳出forEach循环，break和return命令都不行。<br><strong>for…in</strong><br>用于遍历所有的可枚举属性，功能类似于Object.keys()，但是遍历不到constructor、length这样的不可枚举属性。<br>缺点：<br>数组的键名为数字，但是for…in循环是以字符串作为键名”0”,“1”,“2”<br>for…in循环主要是为遍历对象而设计的，不适用于遍历数组。<br><strong>for…of</strong><br>for…of是ES6新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串<br>优点：1、用法简洁 2、可以和break,continue,return配合使用 3、提供了遍历所有数据结构的统一操作接口。<br>三个遍历器对象：<br>entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。<br>keys() 返回一个遍历器对象，用来遍历所有的键名。<br>values() 返回一个遍历器对象，用来遍历所有的键值。</p>
<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p>
<p>普通的对象必须要部署接口后才能使用，用for…in可以，用for…of必须加上Object.keys（obj）方法。</p>
<p><strong>那么什么是可迭代的？</strong></p>
<ul>
<li><p>技术上来说，可迭代对象必须实现Symbol.iterator方法。</p>
<ul>
<li><code>obj[Symbol.iterator]()</code> 的结果被称为 <strong>迭代器（iterator）</strong>。由它处理进一步的迭代过程。</li>
<li>一个迭代器必须有 <code>next()</code> 方法，它返回一个 <code>&#123;done: Boolean, value: any&#125;</code> 对象，这里 <code>done:true</code> 表明迭代结束，否则 <code>value</code> 就是下一个值。</li>
</ul>
</li>
<li><p><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它。</p>
</li>
<li><p>内置的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code>。</p>
</li>
<li><p>举个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.to) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</p>
<p>先来了解一下什么是async和await</p>
<p>函数前面的关键字 <code>async</code> 有两个作用：</p>
<ol>
<li>让这个函数总是返回一个 promise。</li>
<li>允许在该函数内使用 <code>await</code>。</li>
</ol>
<p>Promise 前的关键字 <code>await</code> 使 JavaScript 引擎等待该 promise settle，然后：</p>
<ol>
<li>如果有 error，就会抛出异常 — 就像那里调用了 <code>throw error</code> 一样。</li>
<li>否则，就返回结果。</li>
</ol>
<p>这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。</p>
<p>有了 <code>async/await</code> 之后，我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，<code>Promise.all</code> 是很好用的。</p>
<p><strong>接下来就是比较</strong></p>
<p>回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。（ <strong>回调并不一定就是异步。他们自己并没有直接关系。</strong>）</p>
<p>Promise优点就是回调函数写成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现很多强大的功能。但是缺点是编写复杂。</p>
<p>SetTimeout存在一个问题就是会存在延迟。</p>
<p>async是一种promise的更加高级的写法，更加容易理解与扩充，代码更加简洁</p>
<p>generator生成器函数也是一种可以实现异步的方式，function后加*表示这是一个生成器函数，可以开始和暂停执行，通过返回的内部指针调用next（）方法执行，每一段方法通过yield指定，返回value和done。可以抛出错误。虽然生成器语法简介，但是流程管理却不方便。</p>
</li>
<li><p>js中的map()和reduce()方法</p>
<p>map() 方法：<strong>原数组中的每个元素调用一个指定方法后，返回返回值组成的新数组。</strong></p>
<p>reduce()方法： <strong>为数组中的每一个元素依次执行回调函数（不包括数组中被删除或从未被赋值的元素），返回一个具体的结果。</strong></p>
<ul>
<li>callback （执行数组中每个值的函数，包含四个参数）<ul>
<li>previousValue （第一项的值或者上一次叠加的结果值，或者是提供的初始值（initialValue））</li>
<li>currentValue （数组中当前被处理的元素）</li>
<li>index （当前元素在数组中的索引）</li>
<li>array （数组本身）</li>
</ul>
</li>
<li>initialValue （作为第一次调用 callback 的第一个参数，可以控制返回值的格式）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
