<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Node面经汇总</title>
    <url>/2021/01/18/Node%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>NodeJS基本概念与特点</li>
<li>CommonJS规范、核心模块</li>
<li>Node的异步I/O</li>
<li>Node的内存控制</li>
<li>Node的构建网络服务（TCP、HTTP、WebSocket服务等）</li>
<li>Node的进程</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>OCEANIA项目文档</title>
    <url>/2021/01/18/OCEANIA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="项目背景-amp-概况"><a href="#项目背景-amp-概况" class="headerlink" title="项目背景&amp;概况"></a>项目背景&amp;概况</h2><p>OCEANIA项目的名字实际上是在线代码依赖分析平台的简写，这个平台的设计初衷是希望可以让开发人员在可视化方面对一个项目的代码规模，大致的依赖调用关系有一个大致的认识。同时项目也维护了一个数据库中的图，保存了完整的项目的代码依赖调用关系，后续对于项目的traceability，代码分析之类的提供便利。项目的大致的应用场景是提供给一个拿到新项目的开发者用来熟悉代码结构或者给管理者去监管代码构成以及开发进展的工具平台</p>
<h2 id="项目的技术栈"><a href="#项目的技术栈" class="headerlink" title="项目的技术栈"></a>项目的技术栈</h2><p>前端使用的是Vue框架配合Antdv，使用了vuex以及VueRouter等技术。</p>
<p>后端使用的是Springboot+Mysql以及Jenkins集成部署，还配合Websocket实现了团队通讯功能。</p>
<p>在代码依赖图可视化方面使用的是Cytoscape.js，这个框架提供了很多遍历边点以及对它们还有画布进行操作的API，同时可以自定义布局，因此为了节省浏览器资源，以及优化渲染的效率，我们在后端实现了一个力导向的layout分析算法（首先计算节点之间的斥力，然后根据联通关系计算引力，然后做一些微调之后更新节点位置，迭代调用这个方法200次），提前计算好节点在图上的布局，传到前端进行渲染。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面经汇总</title>
    <url>/2021/01/18/Vue%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>Vue生命周期</li>
<li>介绍一下vuex以及使用场景</li>
<li>vue双向绑定的原理</li>
<li>vue-router实现原理</li>
<li>vue组件之间的通信</li>
<li>vue的一些新技术</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>OASIS项目文档</title>
    <url>/2021/01/18/OASIS%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Webpack面经汇总</title>
    <url>/2021/01/18/Webpack%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>前端工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、项目监控）</p>
</li>
<li><p>Webpack基本概念与配置</p>
</li>
<li><p>webpack配置文件基本概念</p>
</li>
<li><p>webpack构建流程</p>
</li>
<li><p>webpack的优化问题：</p>
<ol>
<li>打包很慢怎么解决</li>
<li>打包出来的文件很大怎么解决</li>
</ol>
<a id="more"></a>
</li>
<li><p><code>webpack</code>原理之普通打包</p>
</li>
<li><p><code>webpack</code>原理之多文件打包</p>
</li>
<li><p><code>webpack</code>原理之提取公共文件</p>
</li>
<li><p><code>webpack</code> 如何做到 tree shaking</p>
</li>
<li><p>前端模块化的理解</p>
</li>
<li><p>loader和plugin的原理与实现</p>
</li>
<li><p>SPA及其优缺点</p>
</li>
<li><p>SSR实现及优缺点</p>
</li>
<li><p>设计模式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能面经汇总</title>
    <url>/2021/01/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><h2 id="你会用什么工具来查找代码中的性能问题？"><a href="#你会用什么工具来查找代码中的性能问题？" class="headerlink" title="你会用什么工具来查找代码中的性能问题？"></a>你会用什么工具来查找代码中的性能问题？</h2><ol>
<li>Profiler（google调试工具）</li>
<li>Lighthouse（chrome浏览器自带）</li>
<li>eslint检查错误</li>
<li>JSPerf</li>
<li>Dromaeo</li>
<li>Vue developer tools</li>
</ol>
</li>
<li><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>chrome中的develop tool -&gt;source可以进行断点调试，可以参看变量，断点一类的</p>
<a id="more"></a>
</li>
<li><h2 id="增强网站的页面滚动效能"><a href="#增强网站的页面滚动效能" class="headerlink" title="增强网站的页面滚动效能"></a>增强网站的页面滚动效能</h2><ol>
<li><p>不要随便让页面进入合成</p>
</li>
<li><p>防抖节流</p>
</li>
<li><p>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参数，该函数会在重绘前调用。requestAnimationFrame(realFunc);rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器）通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000/60 ，触发频率大概是 16.7ms </p>
</li>
<li><p>避免在scroll 事件中修改样式属性，将样式操作从 scroll 事件中剥离</p>
</li>
<li><p>滑动过程中尝试使用 pointer-events: none 禁止鼠标事件</p>
<p>这是一个css样式，用于禁止鼠标行为，比如hover、click失效，即元素不会变成鼠标事件的target，这样增加滚动是的帧频，特别是移动端的时候。滚动时在body上添加pointer-events: none，停止滚动时就去掉。</p>
</li>
</ol>
</li>
<li><h2 id="重排，重绘，合成"><a href="#重排，重绘，合成" class="headerlink" title="重排，重绘，合成"></a>重排，重绘，合成</h2><h3 id="1-页面的呈现流程"><a href="#1-页面的呈现流程" class="headerlink" title="1. 页面的呈现流程"></a>1. 页面的呈现流程</h3><ol>
<li><p>浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</p>
</li>
<li><p>浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</p>
</li>
<li><p>DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个NODE都有自己的style，而且 render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到 render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。</p>
</li>
<li><p>一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzI3LzE2OTJmMzlkMWZhMTU4NGU.png"></p>
</li>
</ol>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/18293586-6ea6536bed94220b.png"></p>
<h3 id="2-什么是回流与重绘"><a href="#2-什么是回流与重绘" class="headerlink" title="2. 什么是回流与重绘"></a>2. 什么是回流与重绘</h3><ol>
<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</li>
<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</li>
<li>回流必将引起重绘，而重绘不一定会引起回流。</li>
</ol>
<p>repaint，就是浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如我们改变了元素的颜色，加个下划线等。</p>
<p>reflow, 浏览器得知元素产生了对文档树排版有影响的样式变化，对所有受影响的dom节点进行重新排版工作</p>
<h3 id="3-回流发生场景"><a href="#3-回流发生场景" class="headerlink" title="3. 回流发生场景"></a>3. 回流发生场景</h3><p>当页面布局和几何属性改变时就需要回流。</p>
<ol>
<li>添加或者删除可见的DOM元素；</li>
<li>元素位置改变；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li>
<li>页面渲染初始化；</li>
<li>浏览器窗口尺寸改变——resize事件发生时；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; document.body.style;</span><br><span class="line">s.padding &#x3D; &quot;2px&quot;; &#x2F;&#x2F; 回流+重绘</span><br><span class="line">s.border &#x3D; &quot;1px solid red&quot;; &#x2F;&#x2F; 再一次 回流+重绘</span><br><span class="line">s.color &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 再一次重绘</span><br><span class="line">s.backgroundColor &#x3D; &quot;#ccc&quot;; &#x2F;&#x2F; 再一次 重绘</span><br><span class="line">s.fontSize &#x3D; &quot;14px&quot;; &#x2F;&#x2F; 再一次 回流+重绘</span><br><span class="line">&#x2F;&#x2F; 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#39;abc!&#39;));</span><br><span class="line"></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<h3 id="4-回流与重绘的影响"><a href="#4-回流与重绘的影响" class="headerlink" title="4.回流与重绘的影响"></a>4.回流与重绘的影响</h3><p>回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。</p>
<h3 id="5-浏览器如何处理"><a href="#5-浏览器如何处理" class="headerlink" title="5. 浏览器如何处理"></a>5. 浏览器如何处理</h3><p>每句JS操作都去回流重绘的话，浏览器可能就会受不了。</p>
<p><strong>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列：</p>
<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>width,height</li>
<li>请求了getComputedStyle(), 或者 IE的 currentStyle</li>
</ol>
<p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。引擎会重新渲染来确保获取的值 是实时的。</p>
<h3 id="6-如何减少回流与重绘"><a href="#6-如何减少回流与重绘" class="headerlink" title="6. 如何减少回流与重绘"></a>6. 如何减少回流与重绘</h3><p>减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。</p>
<ol>
<li>对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</li>
<li>尽可能在DOM树的最末端改变class。避免设置多层内联样式。将动画效果应用到position属性为absolute或fixed的元素上。避免使用CSS表达式（例如：calc()）。</li>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ol>
<h3 id="7-再次理解display-none-与-visibility-hidden-的异同"><a href="#7-再次理解display-none-与-visibility-hidden-的异同" class="headerlink" title="7. 再次理解display:none 与 visibility:hidden 的异同"></a>7. 再次理解display:none 与 visibility:hidden 的异同</h3><ol>
<li>两者都可以在页面上隐藏节点。<ul>
<li>display:none 隐藏后的元素不占据任何空间。它的宽度、高度等各种属性值都将“丢失”</li>
<li>visibility:hidden 隐藏的元素空间依旧存在。它仍具有高度、宽度等属性值</li>
</ul>
</li>
<li>性能的角度而言，即是回流与重绘的方面。<ul>
<li>display:none 会触发 reflow（回流）</li>
<li>visibility:hidden 只会触发 repaint（重绘），因为没有发现位置变化</li>
</ul>
</li>
</ol>
<p>他们两者在优化中 visibility:hidden 会显得更好，因为我们不会因为它而去改变了文档中已经定义好的显示层次结构了。</p>
<p>​    3. 对子元素的影响</p>
<ul>
<li>display:none 一旦父节点元素应用了 display:none，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何设置 display 值都无法显示；</li>
<li>visibility:hidden 一旦父节点元素应用了 visibility:hidden，则其子孙后代也都会全部不可见。不过存在隐藏“失效”的情况。当其子孙元素应用了 visibility:visible，那么这个子孙元素又会显现出来。</li>
</ul>
<h3 id="8-合成层"><a href="#8-合成层" class="headerlink" title="8. 合成层"></a>8. 合成层</h3></li>
<li><h2 id="Babel原理"><a href="#Babel原理" class="headerlink" title="Babel原理"></a>Babel原理</h2><p>babel通俗的来说是一个js的编译器，本质上babel是通过操作AST抽象语法树来完成代码的转译的。</p>
<p>大多数编译器的工作过程可以分为三部分：</p>
<ol>
<li><p>**Parse(解析)**：将源代码转换成更加抽象的表示方法（例如抽象语法树）</p>
<p>分为两个阶段：词法分析和语法分析</p>
<p>词法分析LA将代码分解为Tokens，然后应用语法分析生成AST</p>
</li>
<li><p>**Transform(转换)**：对（抽象语法树）做一些特殊处理，让它符合编译器的期望</p>
<p>dfs，维护了一个Visitor的对象，匹配一个type就可以调用visitor里的方法获取具体的节点，然后根据一定的规则去替换节点</p>
</li>
<li><p>**Generate(代码生成)**：将第二步经过转换过的（抽象语法树）生成新的代码（dfs）</p>
</li>
</ol>
</li>
</ol>
<ol start="6">
<li><h2 id="实现一个幻灯片功能"><a href="#实现一个幻灯片功能" class="headerlink" title="实现一个幻灯片功能"></a>实现一个幻灯片功能</h2></li>
</ol>
<ol start="7">
<li><h2 id="前端优化方法"><a href="#前端优化方法" class="headerlink" title="前端优化方法"></a>前端优化方法</h2><ol>
<li><p>JS CSS极简化, 减少文件大小</p>
</li>
<li><p>真正意义上将样式，配置逻辑embed到页面中，从而减少http请求。CSS放在头部加载，JS放在尾部加载</p>
</li>
<li><p>图片的压缩, 静态资源 CDN化</p>
</li>
<li><p>视图层使用js模版，或者完整的View框架（React），以Lazyload的形式分块加载</p>
</li>
<li><p>CSS JS选择器ID化，ID选择器是最快的。</p>
</li>
<li><p>PC站点和移动端完全分开，拒绝响应式</p>
</li>
<li><p>活用LocalStorage, 存储用户状态, 组件状态，而非JS或者模板</p>
</li>
<li><p>减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器</p>
</li>
<li><p>前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</p>
</li>
<li><p>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</p>
</li>
<li><p>当需要设置的样式很多时设置 className 而不是直接操作 style</p>
</li>
<li><p>少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作</p>
</li>
<li><p>避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)</p>
</li>
<li><p>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</p>
</li>
</ol>
</li>
<li><h2 id="css3动画和js动画对比"><a href="#css3动画和js动画对比" class="headerlink" title="css3动画和js动画对比"></a><code>css3</code>动画和<code>js</code>动画对比</h2><h3 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>js动画控制能力强，可以在动画博凡过程中对动画进行精细控制，开始、暂停、终止、取消都是可以做到的</li>
<li>动画效果比css3动画丰富，比如曲线运动，冲击闪烁，视差滚动效果，只有js动画才能完成</li>
<li>js动画大多数情况下没有兼容性问题，而css3动画有兼容性问题</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>js动画的复杂度高于css3</li>
<li>js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况</li>
<li>js动画往往需要频繁操作DOM的css属性来实现视觉上的动画效果，这个时候浏览器要不停地执行重绘和重排，这对于性能的消耗是很大的，尤其是在分配给浏览器的内存没那么宽裕的移动端。</li>
</ol>
<h3 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><p>部分情况下浏览器可以对动画进行优化，为什么说部分情况下呢，因为是有条件的：</p>
<ul>
<li>在Chromium基础上的浏览器中</li>
<li>同时CSS动画不触发layout或paint，在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。</li>
</ul>
<blockquote>
<p>在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。<br>为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息，例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。</p>
</blockquote>
</li>
<li><p>部分效果可以强制使用硬件加速 （通过 GPU 来提高动画性能）</p>
</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>运行进程控制较弱，css3动画只能在某些场景下控制动画的暂停与继续，不能在特定的位置添加添加回调函数</li>
<li>js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况</li>
</ol>
<h3 id="css动画比js动画流畅的前提"><a href="#css动画比js动画流畅的前提" class="headerlink" title="css动画比js动画流畅的前提"></a>css动画比js动画流畅的前提</h3><ul>
<li>js在执行一些复杂的任务</li>
<li>css动画比较少或者不触发pain和layout，即重绘和重排，例如通过改变如下属性生成的css动画<ul>
<li>backface-visibility</li>
<li>opacity</li>
<li>perspective （设置元素视图）</li>
<li>perspective-origin</li>
<li>transfrom</li>
</ul>
</li>
<li>部分属性能够启动3D加速和GPU硬件加速，例如使用transform的translateZ进行3D变换时</li>
<li>在Chromium基础上的浏览器中，这个貌似是内核做了优化，当css动画知识改变transfrom和opacity时，整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行),这样css动画渲染不会影响主线程。</li>
</ul>
</li>
<li><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>正向代理就是服务端不知道是哪一个客户端访问的</p>
<p>而反向代理就是客户端不知道是访问的哪一个真实的服务器</p>
</li>
<li><h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h2><p>1）概念</p>
<p>线程：是程序执行流的最小单元，是系统独立调度和分配CPU（独立运行）的基本单位。</p>
<p>进程：是资源分配的基本单位。一个进程包括多个线程。</p>
<p>2）区别</p>
<p>1.线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</p>
<p>2.每个进程都有自己一套独立的资源（数据），供其内的所有线程共享。</p>
<p>3.不论是大小，开销线程要更“轻量级”</p>
<p>4.一个进程内的线程通信比进程之间的通信更快速，有效。（因为共享变量）</p>
<p>3）多线程与多进程<br>多线程：同一时刻执行多个线程。用浏览器一边下载，一边听歌，一边看视频，一边看网页。。。</p>
<p>多进程：同时执行多个程序。如，同时运行YY，QQ，以及各种浏览器。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2021/01/16/%E5%BA%8F/</url>
    <content><![CDATA[<p>“那些看似不起波澜的日复一日，会突然在某一天让人看到坚持的意义。”</p>
]]></content>
  </entry>
  <entry>
    <title>毕设交接文档</title>
    <url>/2021/01/16/%E6%AF%95%E8%AE%BE%E4%BA%A4%E6%8E%A5%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="一、项目概况介绍"><a href="#一、项目概况介绍" class="headerlink" title="一、项目概况介绍"></a>一、项目概况介绍</h2><p>一种基于Node.js的web前端页面风格替换系统设计与实现</p>
<p>在Selenium Web Driver基础上搭建了浏览器自动化架构，从素材网页中提取颜色数据和组件数据，之后进行替换以及优化，然后给出评分，在采集和替换过程中留下了原始CSS数据，给用户提供参考。</p>
<p>系统是通过Node.js实现的，一共实现了三个算法：颜色数据采集算法，组件数据采集算法和风格替换算法。在线系统是由React，Egg.js完成的。</p>
<a id="more"></a>

<h2 id="二、技术综述"><a href="#二、技术综述" class="headerlink" title="二、技术综述"></a>二、技术综述</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>将多各种语言编程的脚本转换为JSON格式的接口请求，通过JSONWP通信协议与各浏览器的WebDriver进行通信，最u后WebDriver通过Http协议和真实浏览器进行通信。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>js服务端执行环境，好处是数据类型和语法与浏览器没有太大的差异，Selenium的执行结果也是通过JSON返回，在Node中不需要做类型转换可以直接使用。</p>
<h3 id="主题色提取算法"><a href="#主题色提取算法" class="headerlink" title="主题色提取算法"></a>主题色提取算法</h3><p>基于文档分析。</p>
<h3 id="页面相似度算法"><a href="#页面相似度算法" class="headerlink" title="页面相似度算法"></a>页面相似度算法</h3><p>Edgar Marca的JS版本并且经过了优化。</p>
<h3 id="保留原始CSS"><a href="#保留原始CSS" class="headerlink" title="保留原始CSS"></a>保留原始CSS</h3><p>通过遍历document.styleSheets对象，并且调整了过滤和迭代语法树的规则，并且借助缓存机制对查找性能进行了优化。</p>
<h3 id="页面美观程度评估"><a href="#页面美观程度评估" class="headerlink" title="页面美观程度评估"></a>页面美观程度评估</h3><p>AIM独立部署，并且通过WebSocket通信。</p>
<h3 id="平台构建相关技术"><a href="#平台构建相关技术" class="headerlink" title="平台构建相关技术"></a>平台构建相关技术</h3><p>Egg.js 以Koa为基础，进行了性能的强化，然后通过与MongoDB组合，实现了在线平台的构建。</p>
<p>前端使用了React生态进行展示，React通过对虚拟DOM进行处理，来完成对真实DOM的更新工作。（React服务端渲染）</p>
<h2 id="三、系统分析、设计与实现"><a href="#三、系统分析、设计与实现" class="headerlink" title="三、系统分析、设计与实现"></a>三、系统分析、设计与实现</h2><h3 id="系统分析设计"><a href="#系统分析设计" class="headerlink" title="系统分析设计"></a>系统分析设计</h3><p>在论文中有详细的图标展示，在这里不再赘述。</p>
<h3 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h3><p>颜色/组件采集过程：通过构建两个runner，初始化driver对象并且进行相应的配置。</p>
<p>颜色替换算法采用遍历页面中所有元素并且进行统计，最后再计算各项指标的占比情况。（文档分析方法）；</p>
<p>组件提取算法则是通过首先获取原始css然后对页面执行分割算法（Block-o-Matic），然后构建虚拟DOM树转换成JSON对象返回Node.js端并且分解出片段得到组件数据。同时在展示的时候需要将DOM树片段重新还原成HTML片段。</p>
<p>组件替换算法首先建立对原始页面的虚拟DOM的构建，接着通过相似度算法（Thamme Gowda）进行匹配，最后完成替换。替换完成之后在前端展示中将DOM树重新还原成HTML片段。</p>
<p>颜色替换算法则是随机建立匹配，并且在替换完之后进行优化更改背景色或是调整内容溢出。</p>
<h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>目前能够完成的是基本web语言编写出的页面的颜色和组件的替换，但是仍然有大量的可以改进的空间。</p>
<p>首先是现在很多的前端开发都是使用DSL开发，例如各种框架，或者是Typescript等等，因此第一个改进方向就是替换后的组件能够变成DSL语言。</p>
<p>其次现在替换的结果是完全静态网页，一个HTML页面，而忽略了动态的js交互等等，因为在内容被修改后，JS就已经失效了。那么在后续的工作中，也就是第二个改进方向，就是替换之后能够保留动态的交互效果。为了实现这个方向，可能需要用户对工程化文件做一些修改，例如在webpack阶段load一个插件，暴露一个接口，后期替换的时候可以通过这个接口将所有的样式在源代码上直接替换。</p>
<p>第三个改进方向就是改进替换的效果。例如寻找更加合适的分割算法或者相似度计算算法等等。</p>
<p>第四个方向就是做成一个IDE供开发人员使用，这个方向更偏向工程一些，例如如何页面嵌入一个在线代码编辑器等等。</p>
<p>团队功能：整个替换流程的共享，组件库的共享。</p>
<p>算法方面：结构替换，组件替换，速度上的优化（xpath），语义化。</p>
<p>后端方面：Node + Java</p>
<p>核心改进：针对专业开发人员，提升工作效率。能够在替换完成之后提供源代码，并且提供个性化修改功能。</p>
]]></content>
      <tags>
        <tag>项目</tag>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器相关面经汇总</title>
    <url>/2021/01/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>浏览器输入url之后做了什么？</li>
<li>xss具体</li>
<li>csrf具体</li>
<li>浏览器缓存</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>计网与操作系统面经汇总</title>
    <url>/2021/01/18/%E8%AE%A1%E7%BD%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>TCP/IP协议分层管理</p>
</li>
<li><p>三次握手四次挥手机制及原因</p>
</li>
<li><p>HTTP方法</p>
</li>
<li><p>GET和POST的区别</p>
</li>
<li><p>HTTP建立持久连接的意义</p>
</li>
<li><p>HTTP报文的结构</p>
</li>
<li><p>HTTP状态码</p>
</li>
<li><p>Web服务器及其组成</p>
</li>
<li><p>HTTP报文首部</p>
</li>
<li><p>HTTP通用首部字段</p>
<a id="more"></a>
</li>
<li><p>HTTP请求首部字段、响应首部字段、实体首部字段</p>
</li>
<li><p>Cookie相关首部字段</p>
</li>
<li><p>HTTPS与HTTP区别及实现方式</p>
</li>
<li><p>Cookie与Session</p>
</li>
<li><p>基于HTTP的功能追加协议（SPY、WebSocket、HTTP）</p>
</li>
<li><p>常见的Web攻击分类</p>
</li>
<li><p>TCP与UDP区别</p>
</li>
<li><p>TCP三次握手</p>
</li>
<li><p>存储机制localStorage、sessionStorage与Cookie存储技术</p>
</li>
<li><p>为什么传统上利用多个域名来提供网站资源会更有效</p>
</li>
<li><p><code>Long-Polling</code>、<code>Websockets</code> 和 <code>Server-Sent Event</code></p>
</li>
<li><p>常见的请求头和响应头</p>
</li>
<li><p>和缓存有关的<code>HTTP</code>首部字段</p>
<p>相当重要。如何应用的？</p>
</li>
<li><p><code>https</code> 加密过程</p>
</li>
<li><p><code>http2</code>新特性</p>
</li>
<li><p>计算机系统</p>
</li>
<li><p>线程与进程</p>
</li>
<li><p>常见的git指令</p>
</li>
<li><p>linux相关指令</p>
</li>
<li><p>数据库基本知识</p>
</li>
<li><p>其他类型的编程语言</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Html与Css面经汇总</title>
    <url>/2021/01/17/Html%E4%B8%8ECss%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li><p>DOCTYPE的作用是什么？</p>
<p>DOCTYPE是document type (文档类型) 的缩写。<code>&lt;!DOCTYPE &gt;</code>声明位于文档的最前面，处于标签之前，它不是html标签。主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。不存在这个声明会导致HTML或XHTML以混杂模式出现，把如何渲染的权力交给了浏览器。</p>
<p>P.S. 严格模式和混杂模式都是浏览器的呈现模式，浏览器究竟使用混杂模式还是严格模式呈现页面与网页中的DTD（文件类型定义）有关，DTD里面包含了文档的规则。比如：loose.dtd</p>
<p><strong>严格模式：</strong>又称标准模式，是指浏览器按照W3C标准来解析代码，呈现页面</p>
<p><strong>混杂模式：</strong>又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面。<br>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<a id="more"></a>
</li>
<li><p><code>&lt;a&gt;&lt;/a&gt;</code>标签的全部作用</p>
<p>标签的target属性大致有这几种：<br>（1）_blank<br>（2）_self<br>（3）_parent<br>（4）_top</p>
<p>————————作用1：超链接——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>在一个新的窗口打开连接相应的网页。</span><br><span class="line"></span><br><span class="line">2、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>在原来的窗口打开连接相应的网页。（如果target属性值不写的话，默认是这种方式）</span><br><span class="line"></span><br><span class="line">3、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">4、<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>————————作用2：锚点——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;runtop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">通过<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#runtop&quot;</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>能够实现一个常见的返回顶部的功能。</span><br></pre></td></tr></table></figure>
<p>————————作用3：打电话或者发邮件——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:123456&quot;</span>&gt;</span>打电话给号码为123456的人<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:123456@789.com&quot;</span>&gt;</span>发邮件给给号码为123456@789.com的人<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>————————作用4：协议限定符——————————————–</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&quot;</span>强制运行的<span class="attr">javascript</span>代码&quot;)&quot;&gt;</span>这样就能够在<span class="tag">&lt;<span class="name">a</span>&gt;</span>标签被点击的时候强制运行href属性里面的代码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">这里的href=&quot;javascript:;&quot;，其中javascript:是伪协议，它可以让我们通过一个链接来调用javascript函数.而采用这个方式 javascript:;可以实现A标签的点击事件运行时，如果页面内容很多，有滚动条时，页面不会乱跳，用户体验更好。</span><br></pre></td></tr></table></figure></li>
<li><p>使用data-属性的好处是什么？</p>
<p>data-* 属性是 HTML 5 的新特性，允许用户在 DOM 中存储自定义信息。</p>
<p>以前，需要存储含有特定含义的信息通常是通过 class 完成的，但这并不是 class 本来的用途。现在，利用 HTML 5，可以为元素添加<code>data-*</code>属性，从而存储自定义信息。其中<code>*</code>是可以自定义的部分。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">id</span>=<span class="string">&quot;tu&quot;</span> <span class="attr">data-category</span>=<span class="string">&quot;Web Development&quot;</span> <span class="attr">data-author</span>=<span class="string">&quot;1&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过 JavaScript 访问自定义的信息有两种方式：<code>getAttribute()</code>和<code>dataset</code>。</p>
<h3 id="getAttribute-方法"><a href="#getAttribute-方法" class="headerlink" title="getAttribute 方法"></a>getAttribute 方法</h3><p>这就是经典的取得一个元素属性的方式，和以前一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;tu&#x27;</span>).getAttribute(<span class="string">&#x27;data-category&#x27;</span>); <span class="comment">// &quot;Web Development&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="dataset-方法"><a href="#dataset-方法" class="headerlink" title="dataset 方法"></a>dataset 方法</h3><p>这是 HTML 5 新增的方法，可以更方便的读取所有的 data 信息。并不是所有的浏览器都支持.dataset属性，测试的浏览器中只有Chrome和Opera支持。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tu&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = article.dataset;</span><br><span class="line">alert(data.category); <span class="comment">// &quot;Web Development&quot;</span></span><br><span class="line">alert(data.author); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果把HTML5看作一个开放平台，那他的构建模块有哪些？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>, <span class="tag">&lt;<span class="name">header</span>&gt;</span>,<span class="tag">&lt;<span class="name">section</span>&gt;</span>, <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>H5的语义化作用及语义化标签</p>
<ol>
<li><p>什么是语义化</p>
<p>标签有了自己的含义，通过标签就能判断内容语义。</p>
</li>
<li><p>语义化的好处</p>
<p>1、html结构清晰，代码可读性较好，便于团队维护和开发</p>
<p>2、更有利于搜索引擎或辅助设备理解html页面内容，搜索引擎可以根据标签语言确定上下文和权重关系</p>
</li>
<li><p>常用的语义化标签</p>
<p>section, article, header, footer, nav, figure, dialog, progress, source, video, audio等等</p>
</li>
</ol>
</li>
<li><p>请解释script，script async 和script defer的区别</p>
<p>script：顺序解析执行</p>
<p>defer属性：脚本会被延迟到整个页面都解析完再运行，相当于告诉浏览器立即下载，但是延迟执行。会先于DOMContentLoaded事件执行，但是现实中延迟脚本不一定会按照顺序执行，也不一定再DOMContentLoaded之前执行，因此最好只包含一个延迟脚本。defer属性值针对外部脚本文件，同同时考虑到兼容性，把延迟脚本放在页面底部仍然是最佳选择。</p>
<p>async属性：这个属性同样只适用于外部脚本文件，但与 defer 不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 为此，建议异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之 后执行。</p>
<p>PS：async下载完立即执行，defer待界面文档解析完成之后执行</p>
</li>
<li><p>为什么通常推荐将 CSS <code>&lt;link&gt;</code> 放置在 <code>&lt;head&gt;&lt;/head&gt;</code> 之间，而将 JS <code>&lt;script&gt;</code> 放置在 <code>&lt;/body&gt;</code> 之前？你知道有哪些例外吗？</p>
<p>浏览器在处理HTML页面渲染和JavaScript脚本执行的时候是单一进程的,所以在当浏览器在渲染HTML遇到了<code>&lt;script&gt;</code>标签会先去执行标签内的代码(如果是使用src属性加载的外链文件,则先下载再执行),在这个过程中,页面渲染和交互都会被阻塞。所以将<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前,当页面渲染完成再去执行<code>&lt;script&gt;</code>。</p>
<p>一般希望DOM还没加载必须需要先加载的js会放置在<code>&lt;head&gt;</code>中,有些加了defer、async的<code>&lt;script&gt;</code>也会放在<code>&lt;head&gt;</code>中。</p>
</li>
<li><p>什么是渐进式渲染（progressive rendering）？</p>
<p>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</p>
<p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p>
<p>举例：</p>
<p>（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。</p>
<p>（2）确定显示内容的优先级（<code>分层次渲染</code>）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。</p>
<p>（3）异步加载HTML片段——当页面通过<strong>后台渲染</strong>时，把HTML拆分，通过异步请求，分块发送给浏览器。</p>
</li>
<li><p>HTML和XHTML有什么区别？</p>
<p>XHTML比HTML更加严格，只是按照XML的要求来规范HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. XHTML 元素必须被正确地嵌套。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. XHTML 元素必须被关闭。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.</span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3. 标签名必须用小写字母。</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">P</span>&gt;</span>this is example.<span class="tag">&lt;<span class="name">P</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">p</span>&gt;</span>this is example.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.1 空标签也必须被关闭</span><br><span class="line">错误：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">正确：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">4.XHTML 文档必须拥有根元素。</span><br><span class="line">所有的 XHTML 元素必须被嵌套于 <span class="tag">&lt;<span class="name">html</span>&gt;</span> 根元素中。</span><br><span class="line"></span><br><span class="line">5. XHTML中标签的属性值要使用双引号”。</span><br></pre></td></tr></table></figure></li>
<li><p>HTML5新标签</p>
<p>导航链接<code>&lt;nav&gt;</code>，定义文章标签<code>&lt;article&gt;&lt;/article&gt;</code>, 标题<code>&lt;figure&gt;</code>(还可以和<code>&lt;dt&gt;&lt;dd&gt;</code>联合使用，其中<code>&lt;dt&gt;&lt;/dt&gt;</code>是写标题，而<code>&lt;dd&gt;</code>写内容), 对话框或窗口<code>&lt;dialog&gt;</code>, 菜单<code>&lt;menu&gt;</code>, 标题组<code>&lt;hgroup&gt;</code>, 定义小号文本<code>&lt;small&gt;</code>,</p>
<p>元素的细节<code>&lt;details&gt;</code>, 进度条的标签<code>&lt;progress&gt;</code>, 预定义范围内的度量<code>&lt;meter&gt;</code>, ruby 注释<code>&lt;ruby&gt;</code>.</p>
</li>
<li><p>HTML5新特性</p>
<p>一、语义标签</p>
<p>二、增强型表单</p>
<p>三、视频和音频</p>
<p>四、Canvas绘图</p>
<p>五、SVG绘图</p>
<p>六、地理定位</p>
<p>七、拖放API</p>
<p>八、WebWorker</p>
<p>九、WebStorage</p>
<p>十、WebSocket</p>
</li>
<li><p>SEO概念及实现</p>
<p><strong>SEO简介</strong></p>
<p>　　全称：Search Engine Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。</p>
<p>　　存在的意义：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望百度等搜索引擎能多多我们收录精心制作后的网站，并且在别人访问时网站能排在前面。</p>
<p>　　分类：白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？</p>
<p>　　1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</p>
<p>　　2. 网站内容优化：内容与关键字的对应，增加关键字的密度；</p>
<p>　　3. 在网站上合理设置Robot.txt文件；</p>
<p>　　4. 生成针对搜索引擎友好的网站地图；</p>
<p>　　5. 增加外部链接，到各个网站上宣传；</p>
<p><strong>SEO使用</strong></p>
<ol>
<li><p>网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</p>
<p> 　1. 控制首页链接数量<br>   　2. 扁平化的目录层次<br>   　3. 导航优化（图片导航添加alt，title等属性、面包屑导航）<br>   　4. 网站的结构布局<br>   　5. 控制页面的大小，减少http请求，提高网站的加载速度。</p>
</li>
<li><p>网页代码优化</p>
<p>1.<code>&lt;title&gt;</code>标题</p>
<p>2.<code>&lt;meta keywords&gt;</code>标签</p>
<p>3.<code>&lt;meta description&gt;</code>标签</p>
<p>4.<code>&lt;body&gt;</code>中的标签：尽量让代码语义化</p>
<p>5.<code>&lt;a&gt;</code>标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p>
<p>6.正文标题要用<code>&lt;h1&gt;</code>标签：“蜘蛛” 认为它最重要，若不喜欢<code>&lt;h1&gt;</code>的默认样式可以通过CSS设置。尽量做到正文标题用<code>&lt;h1&gt;</code>标签，副标题用<code>&lt;h2&gt;</code>标签, 而其它地方不应该随便乱用 h 标题标签。</p>
<p>7.<code>&lt;br&gt;</code>标签：只用于文本内容的换行</p>
<p>8.表格应该使用<code>&lt;caption&gt;</code>表格标题标签</p>
<p>9.<code>&lt;img&gt;</code>应使用 “alt” 属性加以说明</p>
<p>10.<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>标签 : 需要强调时使用。<code>&lt;strong&gt;</code>标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，<code>&lt;em&gt;</code>标签强调效果仅次于<code>&lt;strong&gt;</code>标签。<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>标签: 只是用于显示效果时使用，在SEO中不会起任何效果。</p>
<p>11.文本缩进不要使用特殊符号 &nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。</p>
<p>12.巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。</p>
<p>13.重要内容不要用JS输出，因为“蜘蛛”不认识</p>
<p>14.尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容</p>
<p>15.谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。</p>
<p>16.不断精简代码</p>
<p>17.js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。</p>
<ol start="18">
<li>table布局对SEO不友好</li>
</ol>
</li>
</ol>
</li>
<li><p>web worker和web socket</p>
<p>web socket提供更高效的传输协议，web worker提供多线程提高web应用计算效率。</p>
<p><strong>一.web socket</strong></p>
<p>1.web socket是一种协议，本质上和http，tcp一样。协议是用来说明数据是如何传输的,写过一个小的在线聊天使用了socket.io，之后总结这个项目。</p>
<p>2.web socket的前缀有两种：（1）ws://  不是加密的。 (2)wss://  是加密的。</p>
<p>3.客户端和服务端进行web socket交互的方式也可以理解为“http握手 + tcp数据传输”的方式：</p>
<p>（1）浏览器（支持Websocket的浏览器）像HTTP一样，发起一个请求，然后等待服务端的响应；</p>
<p>（2）服务器返回握手响应，告诉浏览器请将后续的数据按照websocket制定的数据格式传过来；</p>
<p>（3）浏览器和服务器的socket连接不中断，此时这个连接和http不同的是它是双工的了；</p>
<p>（4）浏览器和服务器有任何需要传递的数据的时候使用这个长连接进行数据传递。</p>
<p>4.<strong>websocket的数据传输形式</strong>是：frame。比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处：</p>
<p>（1）大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。</p>
<p>（2）和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。</p>
<p>5.客户端使用web socket的语法：JavaScript。</p>
<p>  服务端：多种web框架</p>
<p><strong>二.web worker</strong></p>
<p>1.当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p>
<p>而web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p><strong>除了DOM操作之外</strong>，理论上任何JS脚本任务都可放入worker中执行；语法上的限制，则是<strong>不能跨域访问JS</strong>。worker常用于需要消耗大量时间和CPU资源的复杂计算，以换来前台用户操作的友好型；换句话说，从用户体验上看，<strong>提高了服务性能</strong>。</p>
<p>2.web worker使用：(当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。) 通过向 web worker 添加一个 “onmessage” 事件监听器来获取接受到的消息。发送消息：postMessage()。终止 web worker，并释放浏览器/计算机资源: terminate()。</p>
</li>
</ol>
<hr>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li><p>css画各种图形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">//等腰三角形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等腰梯形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扇形</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//圆</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">border-radius: 25px;//50% 边框半径为宽高的50%</span><br><span class="line">&#125;</span><br><span class="line">半圆</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="comment">/* border-bottom-left-radius: 50px; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>css权重及其引入方式</p>
<p>css的引入可以通过行间样式，内部样式表（head中的style标签内），导入（@import）和外部样式表（<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/global.css&quot;&gt;</code>）引入。</p>
<p>而css权重主要是由数值决定的，权重会叠加，具体对应数值如下：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>！important（css语句后面加）</td>
<td>Infinity</td>
</tr>
<tr>
<td>行间样式</td>
<td>1000</td>
</tr>
<tr>
<td>id</td>
<td>100</td>
</tr>
<tr>
<td>class、属性、伪类</td>
<td>10</td>
</tr>
<tr>
<td>标签、伪元素</td>
<td>1</td>
</tr>
<tr>
<td>通配符、继承的样式</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>什么是文档流（normal flow）</p>
<p>流实际上就是浏览器在页面上摆放Html元素所用的方法，大多数元素默认在文档流中。浏览器从Html文件最上面开始，从上到下沿着元素流逐个显示所遇到的各个元素。即：元素按HTML中编写的先后顺序，上下左右堆叠排列。其中块级元素前后换行，内联元素前后不换行。</p>
<ol>
<li>窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；</li>
<li>每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；</li>
<li>内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；</li>
<li>有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。</li>
</ol>
</li>
<li><p>css定位属性</p>
<p>position：</p>
<ol>
<li>static：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。（默认值）</li>
<li>relative：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</li>
<li>absolute：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。（脱离normal flow）</li>
<li>fixed：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。</li>
<li>sticky：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table<code>时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同</li>
<li>inherit：规定应该从父元素继承 position 属性的值。</li>
</ol>
</li>
<li><p>flex布局</p>
<p>弹性布局：任何一个容器都可以成为flex布局，行内元素也是可以的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br></pre></td></tr></table></figure>
<p>具体的flex布局的容器和项目的属性在这篇博客上有很好的介绍：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</li>
</ol>
<ol start="6">
<li><p>px、em、rem的区别</p>
<p><strong>px像素（Pixel）</strong>。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p>
<p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>
<p><strong>EM特点</strong></p>
<ul>
<li> em的值并不是固定的；</li>
<li> em会继承父级元素的字体大小。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<p>所以我们在写CSS的时候，需要注意两点：</p>
<ul>
<li>\1. body选择器中声明Font-size=62.5%；</li>
<li>\2. 将你的原来的px数值除以10，然后换上em作为单位；</li>
<li>\3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</li>
</ul>
<p>也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</p>
</blockquote>
<p><strong>REM</strong></p>
<p>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>; <span class="attribute">font-size</span>:.<span class="number">875rem</span>;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p>
</blockquote>
<h3 id="px-与-rem-的选择？"><a href="#px-与-rem-的选择？" class="headerlink" title="px 与 rem 的选择？"></a>px 与 rem 的选择？</h3><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。</p>
<p>对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。</p>
</li>
<li><p>IFC与BFC</p>
<p>Box Formatting Context（块级格式化上下文）和Inline Formatting Context</p>
<p><strong>IFC布局规则</strong>：</p>
<blockquote>
<p>在行内格式化上下文中，框(boxes)一个接一个地水平排列，起点是包含块的顶部。水平方向上的 <code>margin</code>，<code>border</code> 和 <code>padding</code>在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</p>
</blockquote>
<p><strong>BFC布局规则</strong>：</p>
<blockquote>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由<code>margin</code>决定。属于同一个BFC的两个相邻Box的<code>margin</code>会发生重叠</li>
<li>每个元素的左外边缘（<code>margin-left</code>)， 与包含块的左边（<code>contain box left</code>）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li>
<li>BFC的区域不会与<code>float box</code>重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
</blockquote>
<p>块级格式化上下文由以下之一创建：</p>
<blockquote>
<ol>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 <code>float</code> 不是 <code>none</code>)</li>
<li>绝对定位的元素 (元素具有 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>非块级元素具有 <code>display: inline-block，table-cell, table-caption, flex, inline-flex</code></li>
<li>块级元素具有<code>overflow</code> ，且值不是 <code>visible</code></li>
</ol>
</blockquote>
<p>BFC的用处为清除浮动，自适应双栏布局，以及消除margin合并之类的能力。（最常见的就是为块级元素添加overflow：hidden）最常见的就是<code>overflow:hidden</code>、<code>float:left/right</code>、<code>position:absolute</code>。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</p>
</li>
<li><p>盒子模型以及理解</p>
<p>css布局是基于盒子模型的。都有如下三个属性</p>
<ul>
<li><code>padding</code>：即内边距，围绕着内容（比如段落）的空间。</li>
<li><code>border</code>：即边框，紧接着内边距的线。</li>
<li><code>margin</code>：即外边距，围绕元素外部的空间。</li>
</ul>
<p>W3C标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p>
</li>
<li><p>Less预处理语言</p>
<p>less是css的扩充，可以通过script或者npm引入，提供了变量（@name），函数，混合模式之类的特性。</p>
</li>
<li><p>三列布局</p>
<p>在这里只讨论两列定宽一列自适应的场景。</p>
<p>可以通过float + margin; float + overflow; table; flex; grid五种方式去实现，这里展示一下flex；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#parent</span> &#123;</span></span><br><span class="line">    height: 500px;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#left</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;  <span class="comment">/*间距*/</span></span></span><br><span class="line">    width: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#center</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;  <span class="comment">/*间距*/</span></span></span><br><span class="line">    width: 200px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#eeff2b</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#right</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">flex</span>: 1;  <span class="comment">/*均分#parent剩余的部分达到自适应*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#0f0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>圣杯布局和双飞翼布局的实现</p>
<p>这两个问题其实是三列布局中的固定两边中间自适应的问题</p>
<p>首先是圣杯布局，使用flex是最简单的方式，当然还可以通过float，绝对定位，grid之类的方法，这里看一下flex的方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.header</span>,<span class="selector-class">.footer</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span>&#123;</span></span><br><span class="line">        flex: 1;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:pink</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        background: aqua;</span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这里是头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>中间部分<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>这里是底部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是双飞翼布局，通过float布局完成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background: red;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 500px;</span><br><span class="line">        background: yellow;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">        margin: 0 200px; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background: blue;</span><br><span class="line">        margin-left: -200px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="12">
<li><p>margin塌陷及合并问题</p>
<p>所谓的margin塌陷是指父子嵌套元素在垂直方向的margin，父子元素是结合在一起的，margin会取最大值。</p>
<p>可以通过设置padding，border或者触发BFC来解决。</p>
<p>而margin合并是指兄弟结构的两个元素在垂直方向上的margin是会合并的。解决方式也是通过BFC，但是在实际开发中，最好不要采用这种改变DOM结构的方式，而是通过只设置一个margin来调节。</p>
</li>
<li><p>vh与vw</p>
<p><strong>视口单位(Viewport units)</strong></p>
<p>什么是视口？ </p>
<p>在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p>
<p>视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport, <strong>“视区”所指为浏览器内部的可视区域大小</strong>，即<code>window.innerWidth/window.innerHeight</code>大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</p>
<p>根据CSS3规范，视口单位主要包括以下4个：</p>
<p>   1.vw：1vw等于视口宽度的1%。</p>
<p>   2.vh：1vh等于视口高度的1%。</p>
<p>   3.vmin：选取vw和vh中最小的那个。（一百等分）</p>
<p>   4.vmax：选取vw和vh中最大的那个。（一百等分）</p>
</li>
<li><p>如何实现响应式布局</p>
</li>
<li><p>z-index和叠加上下文是如何形成的</p>
</li>
<li><p>媒体查询</p>
</li>
<li><p>display以及相关属性</p>
</li>
<li><p>如何实现一个高性能css动画效果</p>
</li>
<li><p>css3动画</p>
</li>
<li><p>垂直水平居中</p>
</li>
<li><p>box-sizing</p>
<p>语法：box-sizing:content-box|border-box|inherit;</p>
<p>设置box-sizing:border-box以后，如果想要一个宽度为200px的盒子，那么我们直接设置宽度为200px。当再设置它的左右边框和左右补白后，它的内容区会自动调整（向里缩进）。</p>
</li>
<li><p>Sass</p>
</li>
<li><p>transform</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2021/01/19/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>Promise（A+规范）、then、all方法</p>
</li>
<li><p>Iterator遍历器实现</p>
</li>
<li><p>Thunk函数实现（结合Generator实现异步）</p>
</li>
<li><p>async实现原理（spawn函数）</p>
</li>
<li><p>class的继承</p>
</li>
<li><p>防抖和节流</p>
<a id="more"></a>
</li>
<li><p>Ajax原生实现</p>
</li>
<li><p>深拷贝的几种方法与比较</p>
</li>
<li><p>继承的几种实现与比较</p>
</li>
<li><p>未知宽高的元素水平垂直居中</p>
</li>
<li><p>三栏布局的实现</p>
</li>
<li><p>两栏布局的实现</p>
</li>
<li><p>Vue高阶组件</p>
</li>
<li><p>数组去重</p>
</li>
<li><p>几种排序算法的实现及其复杂度比较</p>
</li>
<li><p>前序后序遍历二叉树（非递归）</p>
</li>
<li><p>重建二叉树（不含重复数字）</p>
<p>主要流程：新建根节点，查找根节点在中序中对应的索引，构建左右子树，递归解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        list[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> recur = <span class="function"><span class="keyword">function</span>(<span class="params">root, left, right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//指定null以符合treenode格式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line">        <span class="keyword">let</span> i = list[preorder[root]];</span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">        node.right = recur(i - left + root + <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="18">
<li><p>二叉树深度遍历（分析时间复杂度）</p>
</li>
<li><p>跨域的实现（JSONP、CORS）</p>
</li>
<li><p>矩阵搜索（不固定起始位置）</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</li>
</ol>
<pre><code>dfs + 剪枝算法

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || board[i][j] != word[k])&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>))&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="21">
<li><p>矩阵搜索（固定起始位置）：</p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
</ol>
<pre><code>dfs + 剪枝 + 回溯

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        visited[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, si, sj</span>)</span>&#123;</span><br><span class="line">        set = (i, j);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j] == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, ((i + <span class="number">1</span>) % <span class="number">10</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>), sj) + dfs(i, j + <span class="number">1</span>, si, ((j + <span class="number">1</span>) % <span class="number">10</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="22">
<li><p>剪绳子1</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>两个推论即均等长度剪并且x = 3有最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> n - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** a&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** (a - <span class="number">1</span>) * <span class="number">4</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> ** a * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>剪绳子2</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>需要取模，整体的数值kuoda，可能超过上限，因此采用循环取余法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> reminder = <span class="function">(<span class="params">x, a, p</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rem = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a; i++)&#123;</span><br><span class="line">            rem = rem * x % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rem;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> (n - <span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a, p);&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a - <span class="number">1</span>, p) * <span class="number">4</span> % p;&#125;</span><br><span class="line">    <span class="keyword">return</span> reminder(<span class="number">3</span>, a, p) * <span class="number">2</span> % p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>二进制数中的1的个数</p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(count)&#123;</span><br><span class="line">        res += n&amp;<span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要注意的是，如果不是无符号整数，是负数，则需要先取补码-&gt;移动-&gt;低位剪1-&gt;取反</p>
</li>
<li><p>快速幂</p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//二分法快速幂完成</span></span><br><span class="line">    <span class="keyword">if</span>(x === <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">        x = x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>打印从1到最大的n位数（考虑大数问题）</p>
<p>首先看一下原题中的要求，不需要大数：因此随便写写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> ** n; i++)&#123;</span><br><span class="line">        res.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是当要考虑大数的时候就需要通过String类型来实现，结合dfs：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">k</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push(num.slice(i, n).join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            num[k] = i;</span><br><span class="line">            dfs(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> num = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        num.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>简单的删除链表节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next.val == val)&#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>正则匹配</p>
<p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
</li>
</ol>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isMatch = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;<span class="comment">//动态规划，慢慢理解，注意边界值。</span></span><br><span class="line">    <span class="keyword">const</span> m = s.length;</span><br><span class="line">    <span class="keyword">const</span> n = p.length;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">matches</span>(<span class="params">i, j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt;= m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(matches(i, j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(matches(i, j))&#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="29">
<li><p>表示数值的字符串</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<p>//有限状态机，奇技淫巧，用python写写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            &#123; <span class="string">&#x27; &#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">4</span> &#125;, <span class="comment"># 0. start with &#x27;blank&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">4</span> &#125; ,                <span class="comment"># 1. &#x27;sign&#x27; before &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;, <span class="comment"># 2. &#x27;digit&#x27; before &#x27;dot&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;,         <span class="comment"># 3. &#x27;digit&#x27; after &#x27;dot&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span> &#125;,                         <span class="comment"># 4. &#x27;digit&#x27; after &#x27;dot&#x27; (‘blank’ before &#x27;dot&#x27;)</span></span><br><span class="line">            &#123; <span class="string">&#x27;s&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span> &#125;,                 <span class="comment"># 5. &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span> &#125;,                         <span class="comment"># 6. &#x27;sign&#x27; after &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27;d&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;,                 <span class="comment"># 7. &#x27;digit&#x27; after &#x27;e&#x27;</span></span><br><span class="line">            &#123; <span class="string">&#x27; &#x27;</span>: <span class="number">8</span> &#125;                          <span class="comment"># 8. end with &#x27;blank&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>: t = <span class="string">&#x27;d&#x27;</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>: t = <span class="string">&#x27;s&#x27;</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;eE&quot;</span>: t = <span class="string">&#x27;e&#x27;</span>     <span class="comment"># e or E</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;. &quot;</span>: t = c       <span class="comment"># dot, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">&#x27;?&#x27;</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>调整数组顺序使奇数位于偶数前面</p>
<p>简单双指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;left++;&#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;right--;&#125;</span><br><span class="line">        tmp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>链表中倒数第k个节点</p>
<p>依旧是双指针~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = head, q = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &lt; k ? <span class="literal">null</span> : q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>经典题目——反转链表</p>
<p>首先是双指针法，这个方法效率比较低(O N;O 1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = fast.next;</span><br><span class="line">        fast.next = slow;</span><br><span class="line">        slow = fast;</span><br><span class="line">        fast = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后是递归法，先递归到链表的末端，然后在返回的过程中，改变节点的指向（O N; O N)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个有序链表</p>
<p>双指针遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = l1 ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>判断树的子结构</p>
<p>通过两个递归，先序遍历并且判断包不包含子结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a || a.val != b.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(a.left, b.left) &amp;&amp; recur(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>输出二叉树镜像</p>
<p>可以通过递归也可以通过辅助栈解决，这里只展示一下递归法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(node);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>判断二叉树的对称性</p>
<p>递归解决问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">A, B</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; !B)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!A || !B || A.val != B.val)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.right) &amp;&amp; recur(A.right, B.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root ? recur(root.left, root.right) : <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>包含min函数的栈</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>通过辅助栈可以快速解决，期间发现一个问题就是空数组不可以和[ ]比较，因为右端的[ ]会自动转换为true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = [];</span><br><span class="line">    <span class="built_in">this</span>.minimum = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.minimum.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.push(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>] &gt;= x)&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>] == <span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">this</span>.minimum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minimum[<span class="built_in">this</span>.minimum.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>手撕代码</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面经汇总</title>
    <url>/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>事件代理</p>
<p>事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能</p>
<p>具体原因看Q21事件冒泡机制</p>
</li>
<li><p>请解释Javascript中的this是如何工作的（如何正确判断）</p>
<p>this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。</p>
<p>在call和apply中this指向指定的对象，如果指定的参数是null或undefined，则指向window。</p>
<p>在箭头函数中，箭头函数是没有this的，因此this指向外层代码的对象。</p>
<a id="more"></a>
</li>
<li><p>原始值和引用值类型以及区别</p>
<p>JS的原始数据类型有boolean，null，undefined，bigint，number，string，symbol</p>
<p>引用数据类型：对象Object（普通，数组，正则，日期，数学，函数）</p>
<p>区别：</p>
<p>（1）值类型：</p>
<p>​            1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）</p>
<p>​            2、保存与复制的是值本身</p>
<p>​            3、使用typeof检测数据的类型</p>
<p>​            4、基本类型数据是值类型</p>
<p>（2）引用类型：</p>
<p>​            1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</p>
<p>​            2、保存与复制的是指向对象的一个指针</p>
<p>​            3、使用instanceof检测数据类型</p>
<p>​            4、使用new()方法构造出的对象是引用型</p>
</li>
<li><p>闭包与作用域</p>
<p>闭包是指那些能够访问自由变量的函数。（闭包 = 函数 + 函数能够访问的自由变量）/闭包是指有权访问另外一个函数作用域中的变量的函数</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li><p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>
</li>
<li><p>在代码中引用了自由变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();<span class="comment">//0</span></span><br><span class="line">data[<span class="number">1</span>]();<span class="comment">//1</span></span><br><span class="line">data[<span class="number">2</span>]();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>作用域：JS使用词法（静态）作用域，即函数的作用域在函数定义的时候就被确定了</p>
</li>
</ol>
<p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
</li>
<li><p>js继承</p>
<p>js中的继承需要靠原型来实现。</p>
<p>但是继承有一个问题是父类的所有属性，子类都会继承，因此使用组合代替继承是非常必要的。</p>
<p>五种方式实现继承：</p>
<p>​    call（子类中调用parent.call(this)，只能继承属性，但是不能继承方法）</p>
<p>​    借助原型链（child.prototype = new parent()，能继承方法，但是多个子类继承自同一个原型对象，属性值同时改变)</p>
<p>​    前两种组合，但是会导致父类构造函数执行多次</p>
<p>​    将父类原型给到子类的原型（但是子类的构造函数变成了父类）</p>
<p>​    寄生组合继承（最优）</p>
<p>​    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;parent5&#x27;</span>;</span><br><span class="line">   <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent5.call(<span class="built_in">this</span>);</span><br><span class="line">   <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line"> Child5.prototype.constructor = Child5;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>js模块化</p>
<p>AMD,CMD,ES6</p>
<p>AMD和CMD都是通过define()定义模块，AMD需要把依赖的模块先写出来，可以通过return暴露接口，CMD在定义模块需要传入require，exports和module这几个参数，要加载某个模块时，使用require进行加载，要暴露接口时，可以通过exports，module.exports和return。</p>
<p>而es6使用静态化加载而不是运行时加载，通过export和import按需加载（编译时加载）</p>
</li>
<li><p>new的原理</p>
<p>通过new创建对象经历五个步骤：创建一个新对象；设置这个空对象的实例原型；将构造函数的作用域赋给新对象；执行构造函数（赋属性）；返回新对象。</p>
</li>
<li><p>null undefined 区别</p>
<p>null表示”没有对象”，即该处不应该有值。</p>
<p>​    （1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>​    （2） 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>​    （1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>​    （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
</li>
<li><p>IIFE立即执行函数</p>
<p>立即执行函数即立即执行声明的函数（可以是匿名函数），有两种写法</p>
<p>列表1:IIFE写法一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>列表2:IIFE写法二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<ul>
<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。</li>
<li>IIFE中定义的任何变量和函数，都会在执行结束时被销毁，这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</li>
</ul>
</li>
<li><p>原型和原型链</p>
<p>所谓的原型就是在用构造函数创建对象时就会关联另一个对象A.prototype，并且对象会从这里继承属性。（更多像一种委托，建立关联调用）</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/prototype5.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>简而言之构造函数和实例原型之间是原型和构造的关系，对象之间通过__proto__向上调用.</p>
</li>
<li><p>深拷贝与浅拷贝</p>
<p>浅拷贝只拷贝一层对象，但是深拷贝可以通过递归解决对象嵌套的问题</p>
<p>浅拷贝实现方式：</p>
<ol>
<li>手动实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Object.assign</li>
</ol>
<p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;sy&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">&#x27;sss&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>concat浅拷贝数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>slice浅拷贝</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>…展开运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>深拷贝实现方式

简易版本的是JSON.parse(JSON.stringify())，但是这个方法无法解决循环引用，无法拷贝一些set，map之类的特殊对象，无法拷贝函数。

因此手动实现一个深拷贝(如果属性是对象，则递归;有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.get(target))&#123;<span class="keyword">return</span> hash.get(target);&#125;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        hash.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = <span class="keyword">typeof</span> target[prop] === <span class="string">&#x27;object&#x27;</span> ? deepClone(target[prop]) : target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还有jquery有一个提供$.extend 可以使用Deep Copy；函数库lodash的_.cloneDeep方法。</code></pre>
<ol start="12">
<li><p>匿名函数</p>
<p>匿名函数可以赋值或者自执行（IIFE），使用匿名函数赋值的时候，要先声明再使用。IIFE除了上面的方法，还可以通过{[], +, -, !, ~, void}调用</p>
</li>
<li><p>判断数据类型的方式</p>
<ol>
<li>typeof返回基本数据类型（除了null），引用类型中除了function返回function，其余返回object；</li>
<li>toString（）是 Object 的原型方法返回class属性，表示为[Object, Xxx]，除了object其他通过call/apply调用。（window-&gt;global, document-&gt;HTMLDocument）</li>
<li>constructor指向构造函数引用</li>
<li>instanceof通过原型链来判断A是否为B的实例（instance of null报错：右边不是一个对象）</li>
</ol>
</li>
<li><p>宿主对象和原生对象</p>
<p>ECMA-262 把原生对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）</p>
<p>由此可以看出，简单来说，原生对象就是 ECMA-262 定义的类（引用类型）。其中有一个子集叫做内置对象Global和Math（所有函数都必须是某个对象的方法）</p>
<p>所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的 BOM 和 DOM 对象都是宿主对象。document，window， navigator等</p>
</li>
<li><p>请指出以下代码的区别：<code>function Person()&#123;&#125;</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>？</p>
<p>第一个是声明一个函数Person；第二个是把函数的返回值赋给person，如果没有返回值就是undefined；第三个是new一个Person的实例对象。</p>
</li>
<li><p>防抖和节流</p>
<p>简而言之：防抖（debounce）让短时间内的连续触发的事件，在一定的时间间隔中，事件处理函数只执行一次；</p>
<p>而节流（throttle）就是让函数执行一次之后，在一段时间内失效，然后再生效（可以执行）。</p>
</li>
<li><p><code>document.write()</code></p>
<p>用于向HTML输出流中添加传入的内容，浏览器会顺着html元素顺序依次解析他们，并且显示出来，但是如果在页面渲染完成之后调用（onload），会重写整个document，导致之前所有的内容被覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(exp1,exp2,exp3,....);</span><br></pre></td></tr></table></figure></li>
<li><p>Ajax工作原理</p>
<p>Ajax(Asynchronous Java and XML的缩写)是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/v2-320935b9afabe806ff20993ead6c1048_1440w.png"></p>
</li>
<li><p>跨域、同源策略及跨域实现方式和原理</p>
<ol>
<li><p>同源策略是一种规定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求不能发送</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>
<p>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p>
<p>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</p>
<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
</li>
<li><p>跨域的九种解决方案</p>
<ol>
<li>JSONP</li>
<li>CORS(CORS 需要浏览器和后端同时支持。)</li>
<li>postMessage(postMessage是HTML5 XMLHttpRequest Level 2中的API;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。)</li>
<li>websocket</li>
<li>Node中间代理(实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。)</li>
<li>nginx反向代理</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>document.domain + iframe(该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。)</li>
</ol>
</li>
<li><p>总结</p>
<ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>
</li>
</ol>
</li>
<li><p>js中的垃圾回收机制</p>
<p>js中的垃圾回收是自动进行的，是不可见的。js中的内存管理主要的概念是可达性，根访问不到的都是垃圾。垃圾回收器会监视左右的对象并且删除不可访问的对象。基本的垃圾回收算法为标记-清除，垃圾回收器获取根，标记它，然后逐层访问并且标记引用的对象，最后除了标记过的，其余的都删除。（可以是删除没有标记的，又有一种是删除有标记的）（以前还有一种引用计数，但是引用计数会有循环引用的问题）</p>
<p>一些优化:</p>
<ul>
<li><strong>分代回收</strong>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li>
<li><strong>增量回收</strong>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li>
<li><strong>空闲时间收集</strong>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li>
</ul>
</li>
<li><p>冒泡机制</p>
<p>冒泡机制是指事件从DOM树的底层一层层向上传递，如果要终止传递可以通过对每一个元素进行event.stopPropagation()，或者通过在父元素中去判断targetid，分别作出相应的处理。</p>
</li>
<li><p>变量声明提升</p>
<p>变量声明会从他们在代码中出现的位置被移动到当前作用域的最上方进行执行，这个过程叫做提升。</p>
<p>函数也存在提升。但是在函数表达式中，由于是赋值，所以不可以提升。</p>
<p>在提升中有函数优先原则，函数反复声明会覆盖。</p>
<p>当然在实际编程中，要尽量避免提升问题。</p>
</li>
<li><p>document load 和 document DOMContentLoaded</p>
<p>当浏览器解析完文档就会触发DOMContentLoaded事件，脚本，css都会阻塞解析。</p>
<p>而当所有资源全部加载完毕之后，才会触发load事件（在DOMContentLoaded事件之后）。</p>
<p>P.S.为什么要js脚本放在最后（<code>&lt;/body&gt;</code>之前)？</p>
<p>​    其实现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p>
</li>
<li><p>== 和 ===有什么不同</p>
<p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p>
<p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p>
<p>操作数1 == 操作数2， 操作数1 === 操作数2</p>
<p>比较过程：</p>
<p>　　双等号==： </p>
<p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p>
<p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p>
<p>　　　　1）如果一个是null，一个是undefined，那么相等</p>
<p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较(或者是boolean)</p>
<p>　　</p>
<p>　　三等号===:</p>
<p>　　（1）如果类型不同，就一定不相等</p>
<p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值                是否是NaN，只能使用isNaN( ) 来判断）</p>
<p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p>
<p>　　（4）如果两个值都是true，或是false，那么相等</p>
<p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p>
<p>　　（6）如果两个值都是null，或是undefined，那么相等</p>
</li>
<li><p>js中的arguments</p>
<p>也是一个对象，是一个特殊的对象，属性的名是根据传入参数的序列来的，又叫做类数组对象。（proto属性指向Object.prototype）</p>
<p>可以通过length判断传入长度，可以索引取值使用参数，可以通过callee属性获取方法完整代码（匿名函数递归）（es4开始禁止？）</p>
</li>
<li><p>请解释什么是单页应用 (<code>single page app</code>), 以及如何使其对搜索引擎友好 (<code>SEO-friendly</code>)</p>
<p>只有一个页面的web应用程序就是单页应用。</p>
<p>单页应用对SEO不太友好，但是可以通过Prerender预渲染优化技术解决一部分问题。</p>
</li>
<li><p>Promise</p>
<p>Promise的出现解决了回调地狱</p>
<p>什么是回调地狱？</p>
<ol>
<li>多层嵌套的问题。</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<p>Promise 利用了三大技术手段来解决<code>回调地狱</code>:</p>
<ul>
<li><strong>回调函数延迟绑定</strong>。</li>
<li><strong>返回值穿透</strong>。</li>
<li><strong>错误冒泡</strong>。</li>
</ul>
<p>本质上 Promise 是一个函数返回的对象，它代表了一个异步操作的最终完成或者失败。我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<p>Promise由于catch，then，finally返回的是一个新的Promise对象，因此实现了链式调用。</p>
<ul>
<li><p>Promise 中有三个状态 Pending（进行中）、Fulfilled（已成功）、Rejected（已失败）。外界无法改变这个三个状态，而且一旦状态改变就不会再变。</p>
</li>
<li><p>实例化一个 Promise 需要传入一个 <code>executor</code> 函数 ，业务代码在 <code>executor</code> 函数中执行，另外 <code>executor</code> 函数接收两个参数 <code>resolve</code> 和 <code>reject</code>。<code>resolve</code> 和 <code>reject</code> 是 Promise 构造函数的内置函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;... 业务代码</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>executor</code> 函数中业务代码执行成功了，调用 <code>resolve</code> 函数，把 Promise 的状态变为已成功，另外通过参数把业务代码的执行成功的结果传递到 Promise 中。</p>
</li>
<li><p>在 <code>executor</code> 函数中业务代码执行失败了，调用 <code>reject</code> 函数，把 Promise 的状态变为已失败，另外通过参数把业务代码的执行失败的原因传递到 Promise 中。</p>
</li>
<li><p>实例方法 <code>then</code> 的第一个参数是业务代码执行成功的回调函数，第二个参数是业务代码执行失败的回调函数，当业务代码执行完毕后，会根据执行结果调用对应的回调函数，且这些回调函数接收业务代码的执行结果作为参数。</p>
</li>
<li><p>通过实例方法 <code>catch</code> 来添加业务代码执行失败的回调函数。</p>
</li>
</ul>
</li>
<li><p>图片懒加载</p>
<p>图片懒加载实际上就是当页面滚动到当前图片的时候，就进行加载</p>
<p>首先有几个API：</p>
<pre><code>                    1. document.documentElement.clientHeight
                       2. element.offsetTop
                       3. document.documentElement.scrollTop</code></pre>
<p>而懒加载的加载条件就是offsetTop - scrollTop &lt; clientHeight</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        img &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">            margin-bottom: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/7.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/8.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/9.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/10.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//offsetTop是元素与offsetParent的距离，循环获取直到页面顶部</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getTop</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> T = e.offsetTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span>(e = e.offsetParent) &#123;</span></span><br><span class="line">                T += e.offsetTop;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> T;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params">imgs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> H = <span class="built_in">document</span>.documentElement.clientHeight;<span class="comment">//获取可视区域高度</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> S = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (H + S &gt; getTop(imgs[i])) &#123;</span></span><br><span class="line"><span class="javascript">                    imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//onscroll()在滚动条滚动的时候触发</span></span></span><br><span class="line">            lazyLoad(imgs);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更加便捷的一个方式就是通过getBoundingClientRect()，通过返回对象的属性bound.top &lt;= clientHeight（window.innerHeight?）进行判断是不是在视口内。</p>
</li>
<li><p>let var const</p>
<p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象，在全局中声明会变成window的属性；<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，行为基本与let相同，但是在声明的时候必须要初始化变量，在后面出现的代码中不能再修改该常量的值。</p>
</li>
<li><p>什么是事件循环机制？</p>
<p>了解事件循环机制，首先就要去了解什么是同步异步。</p>
<p>js是单线程的，也就是说在JS引擎中负责解释和执行js代码的线程只有一个（主线程和工作线程之分）</p>
<p>同步是指返回的时候能得到预期的值，而异步是只返回时得不到预期的值。</p>
<p>一个异步过程通常是这样的：</p>
<blockquote>
<p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
</blockquote>
<p>异步函数通常具有以下的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A(args..., callbackFn)</span><br></pre></td></tr></table></figure>
<p>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数)<code>A</code></li>
<li>回调函数<code>callbackFn</code></li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。<br><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/3259161542-575018ce29d44_articlex.png"></p>
<p>那么什么是事件循环event loop呢？</p>
<p>事件循环是一种js的执行机制，分为宏任务和微任务。</p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p>
<p>对于宏任务和微任务来说（宏任务一轮循环结束后会在微任务队列中查找）：</p>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126200149.png"></p>
<p>对于Node.js来说有一些不同</p>
<p>nodejs 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<blockquote>
<p><img src="https://first-requirement-graph.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720210126202303.png"></p>
<p>梳理一下 nodejs 三个非常重要的执行阶段:</p>
<ol>
<li>执行 <code>定时器回调</code> 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它<code>timer</code>。</li>
<li>轮询(英文叫<code>poll</code>)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、</li>
</ol>
<p>‘connect’等事件使得事件循环到达 <code>poll</code> 阶段。到达了这个阶段后:</p>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li>如果队列<code>不为空</code>，拿出队列中的方法依次执行</li>
<li>如果队列为空，检查是否有 setImmdiate的回调<ul>
<li>有则前往<code>check阶段</code>(下面会说)</li>
<li><code>没有则继续等待</code>，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后<code>自动进入 check 阶段</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>check 阶段。这是一个比较简单的阶段，直接<code>执行 setImmdiate</code> 的回调。</li>
</ol>
<p>当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 <code>I/O异常的回调阶段</code>。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p>
<p>并且在 check 阶段结束后还会进入到 <code>关闭事件的回调阶段</code>。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， ‘close’ 事件的回调就会在这个阶段执行。</p>
</blockquote>
<p>node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。而 node 版本小于 11 的情况下，对于定时器的处理是: 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p>
<p><strong>nodejs 和 浏览器关于eventLoop的主要区别</strong></p>
<p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>中执行的，而nodejs中的微任务是在<code>不同阶段之间</code>执行的。node中process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<code>优先于微任务</code>执行。</p>
</li>
<li><p>函数柯里化</p>
<p>函数柯里化是一种函数的转换，将一个函数从可调用的f（a, b, c）变成可调用的f（a）（b）（c）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123; <span class="comment">// curry(f) 执行柯里化转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = _.curry(sum); <span class="comment">// 使用来自 lodash 库的 _.curry</span></span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3，仍可正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3，以偏函数的方式调用</span></span><br></pre></td></tr></table></figure>
<p>更加高级的原生实现，可以实现正常或者偏函数方式的调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt;= func.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pass</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<p>箭头函数表达式没有自己的this,arguments,super或new.target。</p>
<p>也就是说不绑定this，没有prototype属性，不能用作生成器，用call，apply调用，第一个参数会被忽略。</p>
<p>还有额外的一点就是箭头函数返回对象字面量的时候，要用括号包起来。</p>
</li>
<li><p>对象创建的三种方法</p>
<p>字面量方法：const obj = { }</p>
<p>new：const obj = new Object()</p>
<p>构造函数：通过function关键字加对象名称来创建</p>
</li>
<li><p>数组的方法</p>
<p>toString() 把数组转换为数组值（逗号分隔）的字符串。（如果需要原始值，则 JavaScript 会自动把数组转换为字符串。）</p>
<p>join() 方法也可将所有数组元素结合为一个字符串。</p>
<p>pop() 方法从数组中删除最后一个元素，返回“被弹出”的值。</p>
<p>push() 方法（在数组结尾处）向数组添加一个新的元素，返回新数组的长度。</p>
<p>shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回被“位移出”的字符串。</p>
<p>unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素，返回新数组的长度。</p>
<p>可以使用 JavaScript delete 运算符来<em>删除</em>，会在数组留下undefined。</p>
<p>splice() 方法可用于向数组添加新项，也可以用来删除元素，第二个参数定义了删除多少个元素，返回一个包含已删除项的数组。</p>
<p>concat() 方法通过合并（连接）现有数组来创建一个新数组，可以拼接任意个数组。</p>
<p>slice() 方法用数组的某个片段切出新数组。</p>
<p>还有sort()（可以自定义比值函数）和reverse()</p>
</li>
<li><p>addEventListener和onClick()的区别</p>
<p>一个是js事件绑定，另一个是普通事件。</p>
<p>普通事件就是直接触发事件，同一时间只能指向同一个对象，所以会被覆盖掉。</p>
<p>事件绑定就是对于一个可以绑定的事件对象，进行多次绑定事件都能运行。</p>
<p>addEventListener对任何DOM都是有效的，而onclick仅限于HTML</p>
<p>addEventListener可以控制listener的触发阶段,（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除。</p>
</li>
<li><p>setTimeout用作倒计时为何会产生误差？</p>
<p>如果当前 <strong>执行栈</strong> 所花费的时间大于 <strong>定时器</strong> 时间，那么定时器的回调在 <strong>宏任务(macrotask)</strong> 里，来不及去调用，所有这个时间会有误差。</p>
<p>我们看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;biubiu&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">某个执行时间很长的函数();</span><br></pre></td></tr></table></figure>
<p>如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 <strong>执行栈</strong> ，要等执行栈执行完毕后再去读取 <strong>微任务(microtask)**，等 **微任务(microtask)</strong> 完成，这个时候才会去读取 <strong>宏任务(macrotask)</strong> 里面的 <strong>setTimeout</strong> 回调函数执行。<strong>setInterval</strong> 同理，例如每3秒放入宏任务，也要等到执行栈的完成。</p>
<p>还有一种情况如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;嘤嘤嘤&#x27;</span>);</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在最新的规范里有这么一句： <strong>If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.</strong></p>
<p>所以意思就是意思就是如果timeout嵌套大于 5层，而时间间隔小于4ms，则时间间隔增加到4ms。</p>
</li>
<li><p>DOM的location对象</p>
</li>
<li><p>call，apply</p>
</li>
<li><p>实现页面加载进度条</p>
</li>
<li><p><code>strict</code>模式</p>
</li>
<li><p>Symbol概念及其作用</p>
</li>
<li><p>Set和Map数据结构</p>
</li>
<li><p>Proxy</p>
</li>
<li><p>Reflect对象</p>
</li>
<li><p>循环语法比较及使用场景（for、forEach、for…in、for…of）</p>
</li>
<li><p>几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
