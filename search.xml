<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Html与Css面经汇总</title>
    <url>/2021/01/17/Html%E4%B8%8ECss%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li>DOCTYPE的作用是什么？</li>
<li><code>&lt;a&gt;&lt;/a&gt;</code>标签的全部作用</li>
<li>使用data-属性的好处是什么？</li>
<li>如果把HTML5看作一个开放平台，那他的构建模块有哪些？</li>
<li>H5的语义化作用及语义化标签</li>
<li>请解释script，script async 和script defer的区别</li>
<li>为什么通常推荐将 CSS <code>&lt;link&gt;</code> 放置在 <code>&lt;head&gt;&lt;/head&gt;</code> 之间，而将 JS <code>&lt;script&gt;</code> 放置在 <code>&lt;/body&gt;</code> 之前？你知道有哪些例外吗？</li>
<li>什么是渐进式渲染（progressive rendering）？</li>
<li>HTML和XHTML有什么区别？</li>
<li>HTML5新标签</li>
<li>HTML5新特性</li>
<li>SEO概念及实现</li>
<li>web worker和web socket</li>
</ol>
<a id="more"></a>

<hr>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li>css画各种图形</li>
<li>css权重及其引入方式</li>
<li>css定位属性</li>
<li>flex布局</li>
<li>px、em、rem的区别</li>
<li>IFC与BFC</li>
<li>盒子模型以及理解</li>
<li>Less预处理语言</li>
<li>三列布局</li>
<li>圣杯布局和双飞翼布局的实现</li>
<li>margin塌陷及合并问题</li>
<li>定位方式以及区别</li>
<li>vh与vw</li>
<li>如何实现响应式布局</li>
<li>z-index和叠加上下文是如何形成的</li>
<li>媒体查询</li>
<li>display以及相关属性</li>
<li>如何实现一个高性能css动画效果</li>
<li>css3动画</li>
<li>垂直水平居中</li>
<li>box-sizing</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面经汇总</title>
    <url>/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>事件代理</p>
<p>事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。例如我们可以通过在父元素上添加子元素实际要执行的事件，以减少与DOM交互的次数，优化性能</p>
<p>具体原因看Q21事件冒泡机制</p>
</li>
<li><p>请解释Javascript中的this是如何工作的（如何正确判断）</p>
<p>this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。</p>
<p>在call和apply中this指向指定的对象，如果指定的参数是null或undefined，则指向window。</p>
<p>在箭头函数中，箭头函数是没有this的，因此this指向外层代码的对象。</p>
<a id="more"></a>
</li>
<li><p>原始值和引用值类型以及区别</p>
<p>JS的原始数据类型有boolean，null，undefined，bigint，number，string，symbol</p>
<p>引用数据类型：对象Object（普通，数组，正则，日期，数学，函数）</p>
<p>区别：</p>
<p>（1）值类型：</p>
<p>​            1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）</p>
<p>​            2、保存与复制的是值本身</p>
<p>​            3、使用typeof检测数据的类型</p>
<p>​            4、基本类型数据是值类型</p>
<p>（2）引用类型：</p>
<p>​            1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</p>
<p>​            2、保存与复制的是指向对象的一个指针</p>
<p>​            3、使用instanceof检测数据类型</p>
<p>​            4、使用new()方法构造出的对象是引用型</p>
</li>
<li><p>闭包与作用域</p>
<p>闭包是指那些能够访问自由变量的函数。（闭包 = 函数 + 函数能够访问的自由变量）/闭包是指有权访问另外一个函数作用域中的变量的函数</p>
<p>从实践角度：以下函数才算是闭包：</p>
<ol>
<li><p>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p>
</li>
<li><p>在代码中引用了自由变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();<span class="comment">//0</span></span><br><span class="line">data[<span class="number">1</span>]();<span class="comment">//1</span></span><br><span class="line">data[<span class="number">2</span>]();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>作用域：JS使用词法（静态）作用域，即函数的作用域在函数定义的时候就被确定了</p>
</li>
</ol>
<p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
</li>
<li><p>js继承</p>
<p>js中的继承需要靠原型来实现。</p>
<p>但是继承有一个问题是父类的所有属性，子类都会继承，因此使用组合代替继承是非常必要的。</p>
<p>五种方式实现继承：</p>
<p>​    call（子类中调用parent.call(this)，只能继承属性，但是不能继承方法）</p>
<p>​    借助原型链（child.prototype = new parent()，能继承方法，但是多个子类继承自同一个原型对象，属性值同时改变)</p>
<p>​    前两种组合，但是会导致父类构造函数执行多次</p>
<p>​    将父类原型给到子类的原型（但是子类的构造函数变成了父类）</p>
<p>​    寄生组合继承（最优）</p>
<p>​    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;parent5&#x27;</span>;</span><br><span class="line">   <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent5.call(<span class="built_in">this</span>);</span><br><span class="line">   <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line"> Child5.prototype.constructor = Child5;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>js模块化</p>
<p>AMD,CMD,ES6</p>
<p>AMD和CMD都是通过define()定义模块，AMD需要把依赖的模块先写出来，可以通过return暴露接口，CMD在定义模块需要传入require，exports和module这几个参数，要加载某个模块时，使用require进行加载，要暴露接口时，可以通过exports，module.exports和return。</p>
<p>而es6使用静态化加载而不是运行时加载，通过export和import按需加载（编译时加载）</p>
</li>
<li><p>new的原理</p>
<p>通过new创建对象经历五个步骤：创建一个新对象；设置这个空对象的实例原型；将构造函数的作用域赋给新对象；执行构造函数（赋属性）；返回新对象。</p>
</li>
<li><p>null undefined 区别</p>
<p>null表示”没有对象”，即该处不应该有值。</p>
<p>​    （1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>​    （2） 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>​    （1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>​    （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
</li>
<li><p>IIFE立即执行函数</p>
<p>立即执行函数即立即执行声明的函数（可以是匿名函数），有两种写法</p>
<p>列表1:IIFE写法一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>列表2:IIFE写法二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<ul>
<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。</li>
<li>IIFE中定义的任何变量和函数，都会在执行结束时被销毁，这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</li>
</ul>
</li>
<li><p>原型和原型链</p>
<p>所谓的原型就是在用构造函数创建对象时就会关联另一个对象A.prototype，并且对象会从这里继承属性。（更多像一种委托，建立关联调用）</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>简而言之构造函数和实例原型之间是原型和构造的关系，对象之间通过__proto__向上调用.</p>
</li>
<li><p>深拷贝与浅拷贝</p>
<p>浅拷贝只拷贝一层对象，但是深拷贝可以通过递归解决对象嵌套的问题</p>
<p>浅拷贝实现方式：</p>
<ol>
<li>手动实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Object.assign</li>
</ol>
<p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;sy&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">&#x27;sss&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>concat浅拷贝数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>slice浅拷贝</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>…展开运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>深拷贝实现方式

简易版本的是JSON.parse(JSON.stringify())，但是这个方法无法解决循环引用，无法拷贝一些set，map之类的特殊对象，无法拷贝函数。

因此手动实现一个深拷贝(如果属性是对象，则递归;有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(taregt)&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.get(target))&#123;<span class="keyword">return</span> hash.get(target);&#125;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        hash.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = <span class="keyword">typeof</span> target[prop] === <span class="string">&#x27;object&#x27;</span> ? deepClone(target[prop]) : target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还有jquery有一个提供$.extend 可以使用Deep Copy；函数库lodash的_.cloneDeep方法。</code></pre>
<ol start="12">
<li><p>匿名函数</p>
<p>匿名函数可以赋值或者自执行（IIFE），使用匿名函数赋值的时候，要先声明再使用。IIFE除了上面的方法，还可以通过{[], +, -, !, ~, void}调用</p>
</li>
<li><p>判断数据类型的方式</p>
<ol>
<li>typeof返回基本数据类型（除了null），引用类型中除了function返回function，其余返回object；</li>
<li>toString（）是 Object 的原型方法返回class属性，表示为[Object, Xxx]，除了object其他通过call/apply调用。（window-&gt;global, document-&gt;HTMLDocument）</li>
<li>constructor指向构造函数引用</li>
<li>instanceof通过原型链来判断A是否为B的实例（instance of null报错：右边不是一个对象）</li>
</ol>
</li>
<li><p>宿主对象和原生对象</p>
<p>ECMA-262 把原生对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）</p>
<p>由此可以看出，简单来说，原生对象就是 ECMA-262 定义的类（引用类型）。其中有一个子集叫做内置对象Global和Math（所有函数都必须是某个对象的方法）</p>
<p>所有非原生对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的 BOM 和 DOM 对象都是宿主对象。global，document，window等</p>
</li>
<li><p>请指出以下代码的区别：<code>function Person()&#123;&#125;</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>？</p>
<p>第一个是声明一个函数Person；第二个是把函数的返回值赋给person，如果没有返回值就是undefined；第三个是new一个Person的实例对象。</p>
</li>
<li><p>防抖和节流</p>
<p>简而言之：防抖（debounce）让短时间内的连续触发的事件，在一定的时间间隔中，事件处理函数只执行一次；</p>
<p>而节流（throttle）就是让函数执行一次之后，在一段时间内失效，然后再生效（可以执行）。</p>
</li>
<li><p><code>document.write()</code></p>
</li>
<li><p>Ajax工作原理</p>
</li>
<li><p>跨域、同源策略及跨域实现方式和原理</p>
</li>
<li><p>js中的垃圾回收机制</p>
</li>
<li><p>冒泡机制</p>
</li>
<li><p>变量声明提升</p>
</li>
<li><p>document load 和 document DOMContentLoaded</p>
</li>
<li><p>== 和 ===有什么不同</p>
</li>
<li><p>js中的arguments</p>
</li>
<li><p>请解释什么是单页应用 (<code>single page app</code>), 以及如何使其对搜索引擎友好 (<code>SEO-friendly</code>)</p>
</li>
<li><p>Promise</p>
</li>
<li><p>图片懒加载</p>
</li>
<li><p>let var const</p>
</li>
<li><p>什么是事件循环机制？</p>
</li>
<li><p>函数柯里化</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>对象创建的三种方法</p>
</li>
<li><p>数组的方法</p>
</li>
<li><p>addEventListener和onClick()的区别</p>
</li>
<li><p>setTimeout用作倒计时为何会产生误差？</p>
</li>
<li><p>DOM的location对象</p>
</li>
<li><p>实现页面加载进度条</p>
</li>
<li><p><code>strict</code>模式</p>
</li>
<li><p>Symbol概念及其作用</p>
</li>
<li><p>Set和Map数据结构</p>
</li>
<li><p>Proxy</p>
</li>
<li><p>Reflect对象</p>
</li>
<li><p>循环语法比较及使用场景（for、forEach、for…in、for…of）</p>
</li>
<li><p>几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node面经汇总</title>
    <url>/2021/01/18/Node%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>NodeJS基本概念与特点</li>
<li>CommonJS规范、核心模块</li>
<li>Node的异步I/O</li>
<li>Node的内存控制</li>
<li>Node的构建网络服务（TCP、HTTP、WebSocket服务等）</li>
<li>Node的进程</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>OASIS项目文档</title>
    <url>/2021/01/18/OASIS%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue面经汇总</title>
    <url>/2021/01/18/Vue%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>Vue生命周期</li>
<li>介绍一下vuex以及使用场景</li>
<li>vue双向绑定的原理</li>
<li>vue-router实现原理</li>
<li>vue组件之间的通信</li>
<li>vue的一些新技术</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack面经汇总</title>
    <url>/2021/01/18/Webpack%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>前端工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、项目监控）</p>
</li>
<li><p>Webpack基本概念与配置</p>
</li>
<li><p>webpack配置文件基本概念</p>
</li>
<li><p>webpack构建流程</p>
</li>
<li><p>webpack的优化问题：</p>
<ol>
<li>打包很慢怎么解决</li>
<li>打包出来的文件很大怎么解决</li>
</ol>
<a id="more"></a>
</li>
<li><p><code>webpack</code>原理之普通打包</p>
</li>
<li><p><code>webpack</code>原理之多文件打包</p>
</li>
<li><p><code>webpack</code>原理之提取公共文件</p>
</li>
<li><p><code>webpack</code> 如何做到 tree shaking</p>
</li>
<li><p>前端模块化的理解</p>
</li>
<li><p>loader和plugin的原理与实现</p>
</li>
<li><p>SPA及其优缺点</p>
</li>
<li><p>SSR实现及优缺点</p>
</li>
<li><p>设计模式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>OCEANIA项目文档</title>
    <url>/2021/01/18/OCEANIA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>序</title>
    <url>/2021/01/16/%E5%BA%8F/</url>
    <content><![CDATA[<p>“那些看似不起波澜的日复一日，会突然在某一天让人看到坚持的意义。”</p>
]]></content>
  </entry>
  <entry>
    <title>前端性能面经汇总</title>
    <url>/2021/01/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>你会用什么工具来查找代码中的性能问题？</p>
</li>
<li><p>增强网站的页面滚动效能</p>
</li>
<li><p>重排，重绘，合成</p>
<p>相当相当重要</p>
</li>
<li><p>Babel原理</p>
</li>
<li><p>实现一个幻灯片功能</p>
</li>
<li><p>合成层</p>
<p>我在这里理解了一个多星期，静下心来去理解。</p>
<p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">http://taobaofed.org/blog/2016/04/25/performance-composite/</a></p>
</li>
<li><p>前端优化方法</p>
</li>
<li><p><code>css3</code>动画和<code>js</code>动画对比</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2021/01/19/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>Promise（A+规范）、then、all方法</p>
</li>
<li><p>Iterator遍历器实现</p>
</li>
<li><p>Thunk函数实现（结合Generator实现异步）</p>
</li>
<li><p>async实现原理（spawn函数）</p>
</li>
<li><p>class的继承</p>
</li>
<li><p>防抖和节流</p>
</li>
<li><p>Ajax原生实现</p>
</li>
<li><p>深拷贝的几种方法与比较</p>
</li>
<li><p>继承的几种实现与比较</p>
</li>
<li><p>未知宽高的元素水平垂直居中</p>
</li>
<li><p>三栏布局的实现</p>
</li>
<li><p>两栏布局的实现</p>
</li>
<li><p>Vue高阶组件</p>
</li>
<li><p>数组去重</p>
</li>
<li><p>几种排序算法的实现及其复杂度比较</p>
</li>
<li><p>前序后序遍历二叉树（非递归）</p>
</li>
<li><p>重建二叉树（不含重复数字）</p>
<p>主要流程：新建根节点，查找根节点在中序中对应的索引，构建左右子树，递归解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; preorder</span><br><span class="line"> * @param &#123;number[]&#125; inorder</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    const list &#x3D; &#123;&#125;;</span><br><span class="line">    for(let i &#x3D; 0; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        list[inorder[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    let recur &#x3D; function(root, left, right)&#123;</span><br><span class="line">        if(left &gt; right)&#123;</span><br><span class="line">            return null;&#x2F;&#x2F;指定null以符合treenode格式</span><br><span class="line">        &#125;</span><br><span class="line">        let node &#x3D; new TreeNode(preorder[root]);</span><br><span class="line">        let i &#x3D; list[preorder[root]];</span><br><span class="line">        node.left &#x3D; recur(root + 1, left, i - 1);</span><br><span class="line">        node.right &#x3D; recur(i - left + root + 1, i + 1, right);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;;</span><br><span class="line">    return recur(0, 0, inorder.length - 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="18">
<li><p>二叉树深度遍历（分析时间复杂度）</p>
</li>
<li><p>跨域的实现（JSONP、CORS）</p>
</li>
<li><p>矩阵搜索（不固定起始位置）</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</li>
</ol>
<pre><code>dfs + 剪枝算法

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || board[i][j] != word[k])&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; board.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>))&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="21">
<li><p>矩阵搜索（固定起始位置）：</p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
</ol>
<pre><code>dfs + 剪枝 + 回溯

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        visited[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j, si, sj</span>)</span>&#123;</span><br><span class="line">        set = (i, j);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j] == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, ((i + <span class="number">1</span>) % <span class="number">10</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>), sj) + dfs(i, j + <span class="number">1</span>, si, ((j + <span class="number">1</span>) % <span class="number">10</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<ol start="22">
<li><p>剪绳子1</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>两个推论即均等长度剪并且x = 3有最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> n - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** a&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">3</span> ** (a - <span class="number">1</span>) * <span class="number">4</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> ** a * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>剪绳子2</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>需要取模，整体的数值kuoda，可能超过上限，因此采用循环取余法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> reminder = <span class="function">(<span class="params">x, a, p</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rem = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a; i++)&#123;</span><br><span class="line">            rem = rem * x % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rem;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;<span class="keyword">return</span> (n - <span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a, p);&#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;<span class="keyword">return</span> reminder(<span class="number">3</span>, a - <span class="number">1</span>, p) * <span class="number">4</span> % p;&#125;</span><br><span class="line">    <span class="keyword">return</span> reminder(<span class="number">3</span>, a, p) * <span class="number">2</span> % p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>手撕代码</tag>
      </tags>
  </entry>
  <entry>
    <title>毕设交接文档</title>
    <url>/2021/01/16/%E6%AF%95%E8%AE%BE%E4%BA%A4%E6%8E%A5%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="一、项目概况介绍"><a href="#一、项目概况介绍" class="headerlink" title="一、项目概况介绍"></a>一、项目概况介绍</h2><p>一种基于Node.js的web前端页面风格替换系统设计与实现</p>
<p>在Selenium Web Driver基础上搭建了浏览器自动化架构，从素材网页中提取颜色数据和组件数据，之后进行替换以及优化，然后给出评分，在采集和替换过程中留下了原始CSS数据，给用户提供参考。</p>
<p>系统是通过Node.js实现的，一共实现了三个算法：颜色数据采集算法，组件数据采集算法和风格替换算法。在线系统是由React，Egg.js完成的。</p>
<a id="more"></a>

<h2 id="二、技术综述"><a href="#二、技术综述" class="headerlink" title="二、技术综述"></a>二、技术综述</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>将多各种语言编程的脚本转换为JSON格式的接口请求，通过JSONWP通信协议与各浏览器的WebDriver进行通信，最u后WebDriver通过Http协议和真实浏览器进行通信。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>js服务端执行环境，好处是数据类型和语法与浏览器没有太大的差异，Selenium的执行结果也是通过JSON返回，在Node中不需要做类型转换可以直接使用。</p>
<h3 id="主题色提取算法"><a href="#主题色提取算法" class="headerlink" title="主题色提取算法"></a>主题色提取算法</h3><p>基于文档分析。</p>
<h3 id="页面相似度算法"><a href="#页面相似度算法" class="headerlink" title="页面相似度算法"></a>页面相似度算法</h3><p>Edgar Marca的JS版本并且经过了优化。</p>
<h3 id="保留原始CSS"><a href="#保留原始CSS" class="headerlink" title="保留原始CSS"></a>保留原始CSS</h3><p>通过遍历document.styleSheets对象，并且调整了过滤和迭代语法树的规则，并且借助缓存机制对查找性能进行了优化。</p>
<h3 id="页面美观程度评估"><a href="#页面美观程度评估" class="headerlink" title="页面美观程度评估"></a>页面美观程度评估</h3><p>AIM独立部署，并且通过WebSocket通信。</p>
<h3 id="平台构建相关技术"><a href="#平台构建相关技术" class="headerlink" title="平台构建相关技术"></a>平台构建相关技术</h3><p>Egg.js 以Koa为基础，进行了性能的强化，然后通过与MongoDB组合，实现了在线平台的构建。</p>
<p>前端使用了React生态进行展示，React通过对虚拟DOM进行处理，来完成对真实DOM的更新工作。（React服务端渲染）</p>
<h2 id="三、系统分析、设计与实现"><a href="#三、系统分析、设计与实现" class="headerlink" title="三、系统分析、设计与实现"></a>三、系统分析、设计与实现</h2><h3 id="系统分析设计"><a href="#系统分析设计" class="headerlink" title="系统分析设计"></a>系统分析设计</h3><p>在论文中有详细的图标展示，在这里不再赘述。</p>
<h3 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h3><p>颜色/组件采集过程：通过构建两个runner，初始化driver对象并且进行相应的配置。</p>
<p>颜色替换算法采用遍历页面中所有元素并且进行统计，最后再计算各项指标的占比情况。（文档分析方法）；</p>
<p>组件提取算法则是通过首先获取原始css然后对页面执行分割算法（Block-o-Matic），然后构建虚拟DOM树转换成JSON对象返回Node.js端并且分解出片段得到组件数据。同时在展示的时候需要将DOM树片段重新还原成HTML片段。</p>
<p>组件替换算法首先建立对原始页面的虚拟DOM的构建，接着通过相似度算法（Thamme Gowda）进行匹配，最后完成替换。替换完成之后在前端展示中将DOM树重新还原成HTML片段。</p>
<p>颜色替换算法则是随机建立匹配，并且在替换完之后进行优化更改背景色或是调整内容溢出。</p>
<h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>目前能够完成的是基本web语言编写出的页面的颜色和组件的替换，但是仍然有大量的可以改进的空间。</p>
<p>首先是现在很多的前端开发都是使用DSL开发，例如各种框架，或者是Typescript等等，因此第一个改进方向就是替换后的组件能够变成DSL语言。</p>
<p>其次现在替换的结果是完全静态网页，一个HTML页面，而忽略了动态的js交互等等，因为在内容被修改后，JS就已经失效了。那么在后续的工作中，也就是第二个改进方向，就是替换之后能够保留动态的交互效果。为了实现这个方向，可能需要用户对工程化文件做一些修改，例如在webpack阶段load一个插件，暴露一个接口，后期替换的时候可以通过这个接口将所有的样式在源代码上直接替换。</p>
<p>第三个改进方向就是改进替换的效果。例如寻找更加合适的分割算法或者相似度计算算法等等。</p>
<p>第四个方向就是做成一个IDE供开发人员使用，这个方向更偏向工程一些，例如如何页面嵌入一个在线代码编辑器等等。</p>
<p>团队功能：整个替换流程的共享，组件库的共享。</p>
<p>算法方面：结构替换，组件替换，速度上的优化（xpath），语义化。</p>
<p>后端方面：Node + Java</p>
<p>核心改进：针对专业开发人员，提升工作效率。能够在替换完成之后提供源代码，并且提供个性化修改功能。</p>
]]></content>
      <tags>
        <tag>毕设</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器相关面经汇总</title>
    <url>/2021/01/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>浏览器输入url之后做了什么？</li>
<li>xss具体</li>
<li>csrf具体</li>
<li>浏览器缓存</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>计网与操作系统面经汇总</title>
    <url>/2021/01/18/%E8%AE%A1%E7%BD%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>TCP/IP协议分层管理</p>
</li>
<li><p>三次握手四次挥手机制及原因</p>
</li>
<li><p>HTTP方法</p>
</li>
<li><p>GET和POST的区别</p>
</li>
<li><p>HTTP建立持久连接的意义</p>
</li>
<li><p>HTTP报文的结构</p>
</li>
<li><p>HTTP状态码</p>
</li>
<li><p>Web服务器及其组成</p>
</li>
<li><p>HTTP报文首部</p>
</li>
<li><p>HTTP通用首部字段</p>
<a id="more"></a>
</li>
<li><p>HTTP请求首部字段、响应首部字段、实体首部字段</p>
</li>
<li><p>Cookie相关首部字段</p>
</li>
<li><p>HTTPS与HTTP区别及实现方式</p>
</li>
<li><p>Cookie与Session</p>
</li>
<li><p>基于HTTP的功能追加协议（SPY、WebSocket、HTTP）</p>
</li>
<li><p>常见的Web攻击分类</p>
</li>
<li><p>TCP与UDP区别</p>
</li>
<li><p>TCP三次握手</p>
</li>
<li><p>存储机制localStorage、sessionStorage与Cookie存储技术</p>
</li>
<li><p>为什么传统上利用多个域名来提供网站资源会更有效</p>
</li>
<li><p><code>Long-Polling</code>、<code>Websockets</code> 和 <code>Server-Sent Event</code></p>
</li>
<li><p>常见的请求头和响应头</p>
</li>
<li><p>和缓存有关的<code>HTTP</code>首部字段</p>
<p>相当重要。如何应用的？</p>
</li>
<li><p><code>https</code> 加密过程</p>
</li>
<li><p><code>http2</code>新特性</p>
</li>
<li><p>计算机系统</p>
</li>
<li><p>线程与进程</p>
</li>
<li><p>常见的git指令</p>
</li>
<li><p>linux相关指令</p>
</li>
<li><p>数据库基本知识</p>
</li>
<li><p>其他类型的编程语言</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
