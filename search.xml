<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Html与Css面经汇总</title>
    <url>/2021/01/17/Html%E4%B8%8ECss%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li>DOCTYPE的作用是什么？</li>
<li><code>&lt;a&gt;&lt;/a&gt;</code>标签的全部作用</li>
<li>使用data-属性的好处是什么？</li>
<li>如果把HTML5看作一个开放平台，那他的构建模块有哪些？</li>
<li>H5的语义化作用及语义化标签</li>
<li>请解释script，script async 和script defer的区别</li>
<li>为什么通常推荐将 CSS <code>&lt;link&gt;</code> 放置在 <code>&lt;head&gt;&lt;/head&gt;</code> 之间，而将 JS <code>&lt;script&gt;</code> 放置在 <code>&lt;/body&gt;</code> 之前？你知道有哪些例外吗？</li>
<li>什么是渐进式渲染（progressive rendering）？</li>
<li>HTML和XHTML有什么区别？</li>
<li>HTML5新标签</li>
<li>HTML5新特性</li>
<li>SEO概念及实现</li>
<li>web worker和web socket</li>
</ol>
<a id="more"></a>

<hr>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li>css画各种图形</li>
<li>css权重及其引入方式</li>
<li>css定位属性</li>
<li>flex布局</li>
<li>px、em、rem的区别</li>
<li>IFC与BFC</li>
<li>盒子模型以及理解</li>
<li>Less预处理语言</li>
<li>三列布局</li>
<li>圣杯布局和双飞翼布局的实现</li>
<li>margin塌陷及合并问题</li>
<li>定位方式以及区别</li>
<li>vh与vw</li>
<li>如何实现响应式布局</li>
<li>z-index和叠加上下文是如何形成的</li>
<li>媒体查询</li>
<li>display以及相关属性</li>
<li>如何实现一个高性能css动画效果</li>
<li>css3动画</li>
<li>垂直水平居中</li>
<li>box-sizing</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面经汇总</title>
    <url>/2021/01/17/Javascript%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>事件代理</p>
</li>
<li><p>请解释Javascript中的this是如何工作的（如何正确判断）</p>
<p>this简而言之就是指向调用函数的对象，如果是全局调用，则this指向window。</p>
<p>在call和apply中this指向指定的对象，如果指定的参数是null或undefined，则指向window。</p>
<p>在箭头函数中，箭头函数是没有this的，因此this指向外层代码的对象。</p>
</li>
<li><p>原始值和引用值类型以及区别</p>
</li>
<li><p>闭包与作用域</p>
</li>
<li><p>js继承</p>
</li>
<li><p>js模块化</p>
</li>
<li><p>new的原理</p>
</li>
<li><p>null undefined 区别</p>
</li>
<li><p>IIFE立即执行函数</p>
</li>
<li><p>原型和原型链</p>
<a id="more"></a>
</li>
<li><p>深拷贝与浅拷贝</p>
</li>
<li><p>匿名函数</p>
</li>
<li><p>判断数据类型的方式</p>
</li>
<li><p>宿主对象和原生对象</p>
</li>
<li><p>请指出以下代码的区别：<code>function Person()&#123;&#125;</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>？</p>
</li>
<li><p>防抖和节流</p>
<p>简而言之：防抖（debounce）让短时间内的连续触发的事件，在一定的时间间隔中，事件处理函数只执行一次；</p>
<p>而节流（throttle）就是让函数执行一次之后，在一段时间内失效，然后再生效（可以执行）。</p>
</li>
<li><p><code>document.write()</code></p>
</li>
<li><p>Ajax工作原理</p>
</li>
<li><p>跨域、同源策略及跨域实现方式和原理</p>
</li>
<li><p>js中的垃圾回收机制</p>
</li>
<li><p>冒泡机制</p>
</li>
<li><p>变量声明提升</p>
</li>
<li><p>document load 和 document DOMContentLoaded</p>
</li>
<li><p>== 和 ===有什么不同</p>
</li>
<li><p>js中的arguments</p>
</li>
<li><p>请解释什么是单页应用 (<code>single page app</code>), 以及如何使其对搜索引擎友好 (<code>SEO-friendly</code>)</p>
</li>
<li><p>Promise</p>
</li>
<li><p>图片懒加载</p>
</li>
<li><p>let var const</p>
</li>
<li><p>什么是事件循环机制？</p>
</li>
<li><p>函数柯里化</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>对象创建的三种方法</p>
</li>
<li><p>数组的方法</p>
</li>
<li><p>addEventListener和onClick()的区别</p>
</li>
<li><p>setTimeout用作倒计时为何会产生误差？</p>
</li>
<li><p>DOM的location对象</p>
</li>
<li><p>实现页面加载进度条</p>
</li>
<li><p><code>strict</code>模式</p>
</li>
<li><p>Symbol概念及其作用</p>
</li>
<li><p>Set和Map数据结构</p>
</li>
<li><p>Proxy</p>
</li>
<li><p>Reflect对象</p>
</li>
<li><p>循环语法比较及使用场景（for、forEach、for…in、for…of）</p>
</li>
<li><p>几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>OCEANIA项目文档</title>
    <url>/2021/01/18/OCEANIA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Node面经汇总</title>
    <url>/2021/01/18/Node%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>NodeJS基本概念与特点</li>
<li>CommonJS规范、核心模块</li>
<li>Node的异步I/O</li>
<li>Node的内存控制</li>
<li>Node的构建网络服务（TCP、HTTP、WebSocket服务等）</li>
<li>Node的进程</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>OASIS项目文档</title>
    <url>/2021/01/18/OASIS%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Webpack面经汇总</title>
    <url>/2021/01/18/Webpack%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>前端工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、项目监控）</p>
</li>
<li><p>Webpack基本概念与配置</p>
</li>
<li><p>webpack配置文件基本概念</p>
</li>
<li><p>webpack构建流程</p>
</li>
<li><p>webpack的优化问题：</p>
<ol>
<li>打包很慢怎么解决</li>
<li>打包出来的文件很大怎么解决</li>
</ol>
<a id="more"></a>
</li>
<li><p><code>webpack</code>原理之普通打包</p>
</li>
<li><p><code>webpack</code>原理之多文件打包</p>
</li>
<li><p><code>webpack</code>原理之提取公共文件</p>
</li>
<li><p><code>webpack</code> 如何做到 tree shaking</p>
</li>
<li><p>前端模块化的理解</p>
</li>
<li><p>loader和plugin的原理与实现</p>
</li>
<li><p>SPA及其优缺点</p>
</li>
<li><p>SSR实现及优缺点</p>
</li>
<li><p>设计模式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面经汇总</title>
    <url>/2021/01/18/Vue%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>Vue生命周期</li>
<li>介绍一下vuex以及使用场景</li>
<li>vue双向绑定的原理</li>
<li>vue-router实现原理</li>
<li>vue组件之间的通信</li>
<li>vue的一些新技术</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能面经汇总</title>
    <url>/2021/01/19/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>你会用什么工具来查找代码中的性能问题？</p>
</li>
<li><p>增强网站的页面滚动效能</p>
</li>
<li><p>重排，重绘，合成</p>
<p>相当相当重要</p>
</li>
<li><p>Babel原理</p>
</li>
<li><p>实现一个幻灯片功能</p>
</li>
<li><p>合成层</p>
<p>我在这里理解了一个多星期，静下心来去理解。</p>
<p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">http://taobaofed.org/blog/2016/04/25/performance-composite/</a></p>
</li>
<li><p>前端优化方法</p>
</li>
<li><p><code>css3</code>动画和<code>js</code>动画对比</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2021/01/16/%E5%BA%8F/</url>
    <content><![CDATA[<p>“那些看似不起波澜的日复一日，会突然在某一天让人看到坚持的意义。”</p>
]]></content>
  </entry>
  <entry>
    <title>毕设交接文档</title>
    <url>/2021/01/16/%E6%AF%95%E8%AE%BE%E4%BA%A4%E6%8E%A5%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="一、项目概况介绍"><a href="#一、项目概况介绍" class="headerlink" title="一、项目概况介绍"></a>一、项目概况介绍</h2><p>一种基于Node.js的web前端页面风格替换系统设计与实现</p>
<p>在Selenium Web Driver基础上搭建了浏览器自动化架构，从素材网页中提取颜色数据和组件数据，之后进行替换以及优化，然后给出评分，在采集和替换过程中留下了原始CSS数据，给用户提供参考。</p>
<p>系统是通过Node.js实现的，一共实现了三个算法：颜色数据采集算法，组件数据采集算法和风格替换算法。在线系统是由React，Egg.js完成的。</p>
<a id="more"></a>

<h2 id="二、技术综述"><a href="#二、技术综述" class="headerlink" title="二、技术综述"></a>二、技术综述</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>将多各种语言编程的脚本转换为JSON格式的接口请求，通过JSONWP通信协议与各浏览器的WebDriver进行通信，最u后WebDriver通过Http协议和真实浏览器进行通信。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>js服务端执行环境，好处是数据类型和语法与浏览器没有太大的差异，Selenium的执行结果也是通过JSON返回，在Node中不需要做类型转换可以直接使用。</p>
<h3 id="主题色提取算法"><a href="#主题色提取算法" class="headerlink" title="主题色提取算法"></a>主题色提取算法</h3><p>基于文档分析。</p>
<h3 id="页面相似度算法"><a href="#页面相似度算法" class="headerlink" title="页面相似度算法"></a>页面相似度算法</h3><p>Edgar Marca的JS版本并且经过了优化。</p>
<h3 id="保留原始CSS"><a href="#保留原始CSS" class="headerlink" title="保留原始CSS"></a>保留原始CSS</h3><p>通过遍历document.styleSheets对象，并且调整了过滤和迭代语法树的规则，并且借助缓存机制对查找性能进行了优化。</p>
<h3 id="页面美观程度评估"><a href="#页面美观程度评估" class="headerlink" title="页面美观程度评估"></a>页面美观程度评估</h3><p>AIM独立部署，并且通过WebSocket通信。</p>
<h3 id="平台构建相关技术"><a href="#平台构建相关技术" class="headerlink" title="平台构建相关技术"></a>平台构建相关技术</h3><p>Egg.js 以Koa为基础，进行了性能的强化，然后通过与MongoDB组合，实现了在线平台的构建。</p>
<p>前端使用了React生态进行展示，React通过对虚拟DOM进行处理，来完成对真实DOM的更新工作。（React服务端渲染）</p>
<h2 id="三、系统分析、设计与实现"><a href="#三、系统分析、设计与实现" class="headerlink" title="三、系统分析、设计与实现"></a>三、系统分析、设计与实现</h2><h3 id="系统分析设计"><a href="#系统分析设计" class="headerlink" title="系统分析设计"></a>系统分析设计</h3><p>在论文中有详细的图标展示，在这里不再赘述。</p>
<h3 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h3><p>颜色/组件采集过程：通过构建两个runner，初始化driver对象并且进行相应的配置。</p>
<p>颜色替换算法采用遍历页面中所有元素并且进行统计，最后再计算各项指标的占比情况。（文档分析方法）；</p>
<p>组件提取算法则是通过首先获取原始css然后对页面执行分割算法（Block-o-Matic），然后构建虚拟DOM树转换成JSON对象返回Node.js端并且分解出片段得到组件数据。同时在展示的时候需要将DOM树片段重新还原成HTML片段。</p>
<p>组件替换算法首先建立对原始页面的虚拟DOM的构建，接着通过相似度算法（Thamme Gowda）进行匹配，最后完成替换。替换完成之后在前端展示中将DOM树重新还原成HTML片段。</p>
<p>颜色替换算法则是随机建立匹配，并且在替换完之后进行优化更改背景色或是调整内容溢出。</p>
<h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>目前能够完成的是基本web语言编写出的页面的颜色和组件的替换，但是仍然有大量的可以改进的空间。</p>
<p>首先是现在很多的前端开发都是使用DSL开发，例如各种框架，或者是Typescript等等，因此第一个改进方向就是替换后的组件能够变成DSL语言。</p>
<p>其次现在替换的结果是完全静态网页，一个HTML页面，而忽略了动态的js交互等等，因为在内容被修改后，JS就已经失效了。那么在后续的工作中，也就是第二个改进方向，就是替换之后能够保留动态的交互效果。为了实现这个方向，可能需要用户对工程化文件做一些修改，例如在webpack阶段load一个插件，暴露一个接口，后期替换的时候可以通过这个接口将所有的样式在源代码上直接替换。</p>
<p>第三个改进方向就是改进替换的效果。例如寻找更加合适的分割算法或者相似度计算算法等等。</p>
<p>第四个方向就是做成一个IDE供开发人员使用，这个方向更偏向工程一些，例如如何页面嵌入一个在线代码编辑器等等。</p>
<p>团队功能：整个替换流程的共享，组件库的共享。</p>
<p>算法方面：结构替换，组件替换，速度上的优化（xpath），语义化。</p>
<p>后端方面：Node + Java</p>
<p>核心改进：针对专业开发人员，提升工作效率。能够在替换完成之后提供源代码，并且提供个性化修改功能。</p>
]]></content>
      <tags>
        <tag>毕设</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器相关面经汇总</title>
    <url>/2021/01/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li>浏览器输入url之后做了什么？</li>
<li>xss具体</li>
<li>csrf具体</li>
<li>浏览器缓存</li>
</ol>
<a id="more"></a>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2021/01/19/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>Promise（A+规范）、then、all方法</p>
</li>
<li><p>Iterator遍历器实现</p>
</li>
<li><p>Thunk函数实现（结合Generator实现异步）</p>
</li>
<li><p>async实现原理（spawn函数）</p>
</li>
<li><p>class的继承</p>
</li>
<li><p>防抖和节流</p>
</li>
<li><p>Ajax原生实现</p>
</li>
<li><p>深拷贝的几种方法与比较</p>
</li>
<li><p>继承的几种实现与比较</p>
</li>
<li><p>未知宽高的元素水平垂直居中</p>
</li>
<li><p>三栏布局的实现</p>
</li>
<li><p>两栏布局的实现</p>
</li>
<li><p>Vue高阶组件</p>
</li>
<li><p>数组去重</p>
</li>
<li><p>几种排序算法的实现及其复杂度比较</p>
</li>
<li><p>前序后序遍历二叉树（非递归）</p>
</li>
<li><p>重建二叉树（不含重复数字）</p>
<p>主要流程：新建根节点，查找根节点在中序中对应的索引，构建左右子树，递归解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; preorder</span><br><span class="line"> * @param &#123;number[]&#125; inorder</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    const list &#x3D; &#123;&#125;;</span><br><span class="line">    for(let i &#x3D; 0; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        list[inorder[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    let recur &#x3D; function(root, left, right)&#123;</span><br><span class="line">        if(left &gt; right)&#123;</span><br><span class="line">            return null;&#x2F;&#x2F;指定null以符合treenode格式</span><br><span class="line">        &#125;</span><br><span class="line">        let node &#x3D; new TreeNode(preorder[root]);</span><br><span class="line">        let i &#x3D; list[preorder[root]];</span><br><span class="line">        node.left &#x3D; recur(root + 1, left, i - 1);</span><br><span class="line">        node.right &#x3D; recur(i - left + root + 1, i + 1, right);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;;</span><br><span class="line">    return recur(0, 0, inorder.length - 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="18">
<li><p>二叉树深度遍历（分析时间复杂度）</p>
</li>
<li><p>跨域的实现（JSONP、CORS）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>手撕代码</tag>
      </tags>
  </entry>
  <entry>
    <title>计网与操作系统面经汇总</title>
    <url>/2021/01/18/%E8%AE%A1%E7%BD%91%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><p>TCP/IP协议分层管理</p>
</li>
<li><p>三次握手四次挥手机制及原因</p>
</li>
<li><p>HTTP方法</p>
</li>
<li><p>GET和POST的区别</p>
</li>
<li><p>HTTP建立持久连接的意义</p>
</li>
<li><p>HTTP报文的结构</p>
</li>
<li><p>HTTP状态码</p>
</li>
<li><p>Web服务器及其组成</p>
</li>
<li><p>HTTP报文首部</p>
</li>
<li><p>HTTP通用首部字段</p>
<a id="more"></a>
</li>
<li><p>HTTP请求首部字段、响应首部字段、实体首部字段</p>
</li>
<li><p>Cookie相关首部字段</p>
</li>
<li><p>HTTPS与HTTP区别及实现方式</p>
</li>
<li><p>Cookie与Session</p>
</li>
<li><p>基于HTTP的功能追加协议（SPY、WebSocket、HTTP）</p>
</li>
<li><p>常见的Web攻击分类</p>
</li>
<li><p>TCP与UDP区别</p>
</li>
<li><p>TCP三次握手</p>
</li>
<li><p>存储机制localStorage、sessionStorage与Cookie存储技术</p>
</li>
<li><p>为什么传统上利用多个域名来提供网站资源会更有效</p>
</li>
<li><p><code>Long-Polling</code>、<code>Websockets</code> 和 <code>Server-Sent Event</code></p>
</li>
<li><p>常见的请求头和响应头</p>
</li>
<li><p>和缓存有关的<code>HTTP</code>首部字段</p>
<p>相当重要。如何应用的？</p>
</li>
<li><p><code>https</code> 加密过程</p>
</li>
<li><p><code>http2</code>新特性</p>
</li>
<li><p>计算机系统</p>
</li>
<li><p>线程与进程</p>
</li>
<li><p>常见的git指令</p>
</li>
<li><p>linux相关指令</p>
</li>
<li><p>数据库基本知识</p>
</li>
<li><p>其他类型的编程语言</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
